<?xml version="1.0" encoding="UTF-8"?>
<chapter id="chapter-configuration" xreflabel="Configuration">
  <title>Configuration</title>

  <para>This covers the configuration for JBoss Remoting discovery, connectors,
  marshallers, and transports. All the configuration properties specified can be
  set either via calls to the object itself, including via JMX (so can be done
  via the JMX or Web console), via a JBoss AS service xml file. Examples of
  service xml configurations can be seen with each of the sections below. There
  is also an example-service.xml file included in the remoting distribution that
  shows full examples of all the remoting configurations. In the presence of the
  JBoss Microcontainer, Remoting servers may be configured by the injection of
  an <classname>org.jboss.remoting.ServerConfiguration</classname> object
  specified in an *-beans.xml file.</para>
  
  <section id="section-configuration"
    xreflabel="General transport configuration">
    <title>General transport configuration</title>

    <para>Remoting offers a variety of ways of configuring transports on the
    server side and client side. This section presents an overview, and the
    rest of the chapter elaborates the material presented here. For easy
    reference the configuration parameters discussed throughout the chapter
    are gathered together at the end of the chapter in section <xref
    linkend="section-configuration-by-properties" /></para>

    <section>
      <title>Server side configuration</title>

      <para>The heart of the server side is the
      <classname>Connector</classname>, and it is through the
      <classname>Connector</classname> that the server side of a transport is
      configured. The central goals of configuration on the server side are to
      establish a server invoker and supply it with a set of invocation
      handlers. Only one invoker can be declared per
      <classname>Connector</classname>. Although declaring an invocation
      handler is not required, it should only be omitted in the case of
      declaring a callback server that will not receive direct invocations,
      but only callback messages. Otherwise client invocations can not be
      processed. The invocation handler is the only interface that is required
      by the remoting framework for a user to implement and will be what the
      remoting framework calls upon when receiving invocations.</para>

      <para>There are two general approaches to server side configuration:
      programmatic and declarative. A variety of programmatic techniques work
      in any environment, including the JBoss Application Server (JBossAS).
      Moreover, JBossAS adds the option of declarative configuration. In
      particular, the SARDeployer (see The JBoss 4 Application Server Guide on
      the labs.jboss.org web site) can read information from a *-service.xml
      file and use it to configure MBeans such as
      <classname>Connector</classname>s.</para>

      <section id="section-programmatic-configuration" xreflabel="Programmatic      configuration">
      
        <title>Programmatic configuration.</title>

        <para>The simplest way to configure a <classname>Connector</classname>
        is to pass an <classname>InvokerLocator</classname> to a
        <classname>Connector</classname> constructor. For example, the code
        fragment</para>

        <programlisting>String locatorURI = "socket://test.somedomain.com:8084";
String params = "/?clientLeasePeriod=10000&amp;timeout=120000";
locatorURI += params;
InvokerLocator locator = new InvokerLocator(locatorURI);
Connector connector = new Connector(locator);
connector.create();
SampleInvocationHandler invocationHandler = new SampleInvocationHandler();
connector.addInvocationHandler("sample", invocationHandler);
connector.start();</programlisting>

        <para>creates a server invoker based on the socket transport, directs
        it to listen for invocations on port 8084 of host test.somedomain.com,
        and passes two configuration parameters, "clientLeasePeriod" and
        "timeout". It also supplies the server invoker with an invocation
        handler.</para>

        <para>One limitation of the <classname>InvokerLocator</classname> is
        that it can only represent string values. An alternative that
        overcomes this limitation is to pass some or all of the parameters to
        the <classname>Connector</classname> by way of a configuration map.
        The following code fragment accomplishes all that the previous
        fragment does, but it passes one parameter by way of the
        <classname>InvokerLocator</classname> and passes the other by way of a
        configuration map. It also passes in a non-string object, a
        <classname>ServerSocketFactory</classname>:</para>

        <programlisting>String locatorURI = "socket://test.somedomain.com:8084";
String params = "/?clientLeasePeriod=10000";
locatorURI += params;
InvokerLocator locator = new InvokerLocator(locatorURI);
HashMap config = new HashMap();
config.put(ServerInvoker.TIMEOUT, "120000");
config.put(ServerInvoker.SERVER_SOCKET_FACTORY, new MyServerSocketFactory());
Connector connector = new Connector(locator, config);
connector.create();
SampleInvocationHandler invocationHandler = new SampleInvocationHandler();
connector.addInvocationHandler("sample", invocationHandler);
connector.start();</programlisting>

        <para>Note that the value of <code>ServerInvoker.TIMEOUT</code> is
        "timeout", and the value of
        <code>ServerInvoker.SERVER_SOCKET_FACTORY</code> is
        "serverSocketFactory". These configuration map keys are discussed
        throughout the chapter and accumulated in section <xref
        linkend="section-configuration-by-properties" />. Also, server socket factory
        configuration is covered in <xref
        linkend="section-socket-factories" />.</para>

        <para>A third programmatic option is available for those configuration
        properties which happen to be server invoker MBean properties. In the
        following fragment, the server invoker is obtained from the
        <classname>Connector</classname> and a
        <classname>ServerSocketFactory</classname> is passed to it by way of a
        setter method:</para>

        <programlisting>String locatorURI = "socket://test.somedomain.com:8084";
String params = "/?clientLeasePeriod=10000";
locatorURI += params;
InvokerLocator locator = new InvokerLocator(locatorURI);
HashMap config = new HashMap();
config.put(ServerInvoker.TIMEOUT, "120000");
Connector connector = new Connector(locator, config);
connector.create();
ServerInvoker serverInvoker = connector.getServerInvoker();
ServerSocketFactory ssf = new MyServerSocketFactory();
serverInvoker.setServerSocketFactory(ssf);
SampleInvocationHandler invocationHandler = new SampleInvocationHandler();
connector.addInvocationHandler("sample", invocationHandler);
connector.start();</programlisting>

        <para><emphasis role="bold">Note.</emphasis> The
        <classname>Connector</classname> creates the server invoker during the
        call to <methodname>Connector.create()</methodname>, so this option
        only works after that method has been called. Also, depending on the
        parameter and the transport, this option may or may not be effective
        after the call to <methodname>Connector.start()</methodname>, which
        calls <methodname>start()</methodname> on the server invoker.</para>

        <para>A fourth option, which exists primarily to support the
        declarative mode of configuration presented below, is to pass an XML
        document to the <classname>Connector</classname>. The following
        fragment duplicates the behavior of the first and second examples
        above.</para>

        <programlisting>HashMap config = new HashMap();
config.put(ServerInvoker.TIMEOUT, "120000");
Connector connector = new Connector(config);

// Set xml configuration element.
StringBuffer buf = new StringBuffer();
buf.append("&lt;?xml version=\"1.0\"?&gt;\n");
buf.append("&lt;config&gt;");
buf.append("   &lt;invoker transport=\"socket\"&gt;");
buf.append("      &lt;attribute name=\"serverBindAddress\"&gt;test.somedomain.com&lt;/attribute&gt;");
buf.append("      &lt;attribute name=\"serverBindPort\"&gt;8084&lt;/attribute&gt;");
buf.append("      &lt;attribute name=\"clientLeasePeriod\"&gt;10000&lt;/attribute&gt;");
buf.append("   &lt;/invoker&gt;");
buf.append("   &lt;handlers&gt;");
buf.append("      &lt;handler subsystem=\"mock\"&gt;");
buf.append("         org.jboss.remoting.transport.mock.SampleInvocationHandler");
buf.append("      &lt;/handler&gt;");
buf.append("   &lt;/handlers&gt;");
buf.append("&lt;/config&gt;");

ByteArrayInputStream bais = new ByteArrayInputStream(buf.toString().getBytes());
Document xml = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(bais);
connector.setConfiguration(xml.getDocumentElement());

connector.create();
connector.start();</programlisting>

        <para>Note that there is no <classname>InvokerLocator</classname> in
        this example. If the <classname>Connector</classname> gets an
        <classname>InvokerLocator</classname>, it ignores the presence of the
        xml document. Note also that this method only supports the use of
        string values, so it is necessary to include the fully qualified name
        of the invocation handler, from which the handler is created by
        calling the default constructor.</para>

        <para>An example of this option in use can be found in
        <classname>org.jboss.test.remoting.configuration.SocketClientConfigurationTestCase</classname>.</para>

        <para>A fifth option, which exists primarily to support the injection of
        POJOs in the presence of the JBoss Microcontainer, is to pass an
        <classname>org.jboss.remoting.ServerConfiguration</classname> object to
        the <methodname>Connector.setServerConfiguration()</methodname> method.
        The following fragment duplicates the behavior of the first and second
        examples above.</para>
        
        <programlisting>HashMap config = new HashMap();
config.put(ServerInvoker.TIMEOUT, "120000");
Connector connector = new Connector(config);

// Create ServerConfiguration object for socket transport
ServerConfiguration serverConfig = new ServerConfiguration("socket");

// Add invokerLocatorParameters (applicable to client and server)
Map locatorConfig = new HashMap();
locatorConfig.put("serverBindAddress", "test.somedomain.com");
locatorConfig.put("serverBindPort", "8084");
serverConfig.setInvokerLocatorParameters(locatorConfig);

// Add serverParameters (applicable to server)
Map serverParameters = new HashMap();
locatorConfig.put("clientLeasePeriod", "10000");
serverConfig.setServerParameters(serverParameters);

// Add invocation handlers
Map handlers = new HashMap();
handlers.put("mock", "org.jboss.remoting.transport.mock.SampleInvocationHandler");
serverConfig.setInvocationHandlers(handlers);

connector.setServerConfiguration(serverConfig);
connector.create();
connector.start();</programlisting>
          
        <para>For more information about <classname>ServerConfiguration</classname>,
        see the section "Declarative configuration: POJOs".</para>
       
       </section>
      
       <section id="section-declarative-configuration-mbeans" xreflabel="Declarative configuration: MBeans">
        <title>Declarative configuration: MBeans</title>

        <para>One configuration option discussed in Section <xref
        linkend="section-programmatic-configuration" />, passing an XML document
        to the <classname>Connector</classname>, works in conjunction with the
        service archive deployer (SARDeployer) inside the JBoss Application
        Server to allow declarative configuration on the server side. In
        particular, the SARDeployer reads XMl documents containing MBean
        descriptors from files whose name has the form "*-service.xml". When
        it sees a descriptor for a <classname>Connector</classname> MBean, it
        passes the descriptor's <code>&lt;config&gt;</code> element to a newly
        created <classname>Connector</classname>.</para>

        <para>There are two ways in which to specify the server invoker
        configuration via a service xml file. The first is to specify just the
        InvokerLocator attribute as a sub-element of the Connector MBean. For
        example, a possible configuration for a Connector using a socket
        invoker that is listening on port 8084 on the test.somedomain.com
        address would be:</para>

        <programlisting>&lt;mbean code="org.jboss.remoting.transport.Connector"
       name="jboss.remoting:service=Connector,transport=Socket"
       display-name="Socket transport Connector"&gt;
   &lt;attribute name="<emphasis role="bold">InvokerLocator</emphasis>"&gt;
      &lt;![CDATA[<emphasis role="bold">socket://test.somedomain.com:8084</emphasis>]]&gt;
   &lt;/attribute&gt;
   &lt;attribute name="Configuration"&gt;
      &lt;config&gt;
         &lt;handlers&gt;
            &lt;handler <emphasis role="bold">subsystem</emphasis>="mock"&gt;
               <emphasis role="bold">org.jboss.remoting.transport.mock.MockServerInvocationHandler</emphasis>
            &lt;/handler&gt;
         &lt;/handlers&gt;
      &lt;/config&gt;
   &lt;/attribute&gt;
&lt;/mbean&gt;</programlisting>

        <para>Note that all the server side socket invoker configurations will
        be set to their default values in this case. Also, it is important to
        add CDATA to any locator uri that contains more than one
        parameter.</para>

        <para>The other way to configure the Connector and its server invoker
        in greater detail is to provide an <code>invoker</code> sub-element
        within the config element of the Configuration attribute. The only
        attribute of invoker element is transport, which will specify which
        transport type to use (e.g.. socket, rmi, or http). All the
        sub-elements of the invoker element will be attribute elements with a
        name attribute specifying the configuration property name and then the
        value. An <code>isParam</code> attribute can also be added to indicate
        that the attribute should be added to the locator uri, in the case the
        attribute needs to be used by the client. An example using this form
        of configuration is as follows:</para>

        <programlisting>&lt;mbean code="org.jboss.remoting.transport.Connector"
       name="jboss.remoting:service=Connector,transport=Socket"
       display-name="Socket transport Connector"&gt;
   
   &lt;attribute name="Configuration"&gt;
      &lt;config&gt;
         <emphasis role="bold"> 
         &lt;invoker transport="socket"&gt;
            &lt;attribute name="numAcceptThreads"&gt;1&lt;/attribute&gt;
            &lt;attribute name="maxPoolSize"&gt;303&lt;/attribute&gt;
            &lt;attribute name="clientMaxPoolSize" isParam="true"&gt;304&lt;/attribute&gt;
            &lt;attribute name="socketTimeout"&gt;60000&lt;/attribute&gt;
            &lt;attribute name="serverBindAddress"&gt;192.168.0.82&lt;/attribute&gt;
            &lt;attribute name="serverBindPort"&gt;6666&lt;/attribute&gt;
            &lt;attribute name="clientConnectAddress"&gt;216.23.33.2&lt;/attribute&gt;
            &lt;attribute name="clientConnectPort"&gt;7777&lt;/attribute&gt;
            &lt;attribute name="enableTcpNoDelay" isParam="true"&gt;false&lt;/attribute&gt;
            &lt;attribute name="backlog"&gt;200&lt;/attribute&gt;
         &lt;/invoker&gt;
         </emphasis>
         &lt;handlers&gt;
            &lt;handler subsystem="mock"&gt;
               org.jboss.remoting.transport.mock.MockServerInvocationHandler
            &lt;/handler&gt;
         &lt;/handlers&gt;
      &lt;/config&gt;
   &lt;/attribute&gt;
   
&lt;/mbean&gt;</programlisting>

        <para>Also note that <code>${jboss.bind.address}</code> can be used
        for any of the bind address properties, which will be replaced with
        the bind address specified to JBoss when starting (i.e. via the -b
        option).</para>

        <para>All the attributes set in this configuration could be set
        directly in the locator uri of the InvokerLocator attribute value, but
        would be much more difficult to decipher visually and is more prone to
        editing mistakes.</para>

        <para>One of the components of a locator uri that can be expressed
        within the InvokerLocator attribute is the path. For example, can
        express a locator uri path of 'foo/bar' via the InvokerLocator
        attribute as:</para>

        <programlisting>&lt;attribute name="InvokerLocator"&gt;
   &lt;![CDATA[socket://test.somedomain.com:8084/<emphasis role="bold">foo/bar</emphasis>]]&gt;
&lt;/attribute&gt;</programlisting>

        <para>To include the path using the Configuration attribute, can
        include a specific 'path' attribute. So the same InvokerLocator can be
        expressed as follows with the Configuration attribute:</para>

        <programlisting>&lt;attribute name="Configuration"&gt;
   &lt;config&gt;
      &lt;invoker transport="socket"&gt;
         &lt;attribute name="serverBindAddress"&gt;test.somedomain.com&lt;/attribute&gt;
         &lt;attribute name="serverBindPort"&gt;8084&lt;/attribute&gt;
         <emphasis role="bold">&lt;attribute name="path"&gt;foo/bar&lt;/attribute&gt;</emphasis>
      &lt;/invoker&gt;
      ...</programlisting>

        <para>Note: The value for the 'path' attribute should NOT start or end
        with a / (slash).</para>
      </section>
      
      <section id="section-declarative-configuration-pojos" xreflabel="Declarative configuration: POJOs">
        <title>Declarative configuration: POJOs</title>

        <para>The last configuration option discussed in Section <xref
        linkend="section-programmatic-configuration" />, passing an
        <classname>org.jboss.remoting.ServerConfiguration</classname> object to
        the <methodname>Connector.setServerConfiguration()</methodname> method,
        works in conjunction with the JBoss Microcontainer, which supports the
        injection of POJOs. In particular, the Microcontainer reads XML
        documents containing POJO descriptors from files whose name has the form
        "*-beans.xml".</para>
        
        <para>A <classname>ServerConfiguration</classname> object holds four components:</para>

        <itemizedlist>
          <listitem>
            <para>transport (supplied by constructor)</para>
          </listitem>
          <listitem>
            <para>invokerLocatorParameters: this is a map of all parameter names
            and values that will go into the
            org.jboss.remoting.InvokerLocator</para>
          </listitem>
          <listitem>
            <para>serverParameters: this is a map of parameter names and values
            that will be used by the server but will not go into the
            InvokerLocator</para>
          </listitem>
          <listitem>
            <para>invocationHandlers: this is a map of invocation handlers. The key
            is the subsystem, or comma separated list of subsystems.</para>
          </listitem>
        </itemizedlist>
        
        <para>A sample remoting-beans.xml file which duplicates the example in the
        previous sections is:</para>
                                       
        <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;deployment xmlns="urn:jboss:bean-deployer:2.0"&gt;
            
   &lt;bean name="remoting:invocationHandler"
         class="org.jboss.remoting.transport.mock.SampleInvocationHandler"/&gt;
             
   &lt;bean name="remoting:serverConfiguration"
         class="org.jboss.remoting.ServerConfiguration"&gt;
      &lt;constructor&gt;
         &lt;parameter&gt;socket&lt;/parameter&gt;
      &lt;/constructor&gt;
      &lt;property name="invokerLocatorParameters"&gt;
         &lt;map keyClass="java.lang.String" valueClass="java.lang.String"&gt;
            &lt;entry&gt;
               &lt;key&gt;serverBindAddress&lt;/key&gt;
               &lt;value&gt;test.somedomain.com&lt;/value&gt;
            &lt;/entry&gt;
            &lt;entry&gt;
               &lt;key&gt;serverBindPort&lt;/key&gt;
               &lt;value&gt;8084&lt;/value&gt;
            &lt;/entry&gt;
         &lt;/map&gt;
      &lt;/property&gt;
      &lt;property name="serverParameters"&gt;
         &lt;map keyClass="java.lang.String" valueClass="java.lang.String"&gt;
            &lt;entry&gt;
               &lt;key&gt;clientLeasePeriod&lt;/key&gt;
               &lt;value&gt;10000&lt;/value&gt;
            &lt;/entry&gt;
         &lt;/map&gt;
      &lt;/property&gt;
      &lt;property name="invocationHandlers"&gt;
         &lt;map keyClass="java.lang.String" 
              valueClass="org.jboss.remoting.ServerInvocationHandler"&gt;
            &lt;entry&gt;
               &lt;key&gt;mock&lt;/key&gt;
               &lt;value&gt;&lt;inject bean="remoting:invocationHandler"/&gt;&lt;/value&gt;
            &lt;/entry&gt;
         &lt;/map&gt;
      &lt;/property&gt;
   &lt;/bean&gt;
             
   &lt;bean name="remoting:connector" class="org.jboss.remoting.transport.Connector"&gt;
      &lt;property name="serverConfiguration"&gt;
         &lt;inject bean="remoting:serverConfiguration"/&gt;
      &lt;/property&gt;
   &lt;/bean&gt;
             
&lt;/deployment&gt;</programlisting>
        
        <para>For more information about using the JBoss Microcontainer, see
        <ulink url="http://www.jboss.org/jbossmc/">
        http://www.jboss.org/jbossmc/</ulink>.</para>

      </section>
     
      <section>
        <title>Callback client configuration</title>
        
        <para>
          Remoting supports asynchronous computation and delivery of results
          through a callback mechanism, as described in Section <xref
          linkend="section-callbacks"/>. Callbacks are sent from the server side
          to the client side on a callback connection which is the reverse of
          the usual client to server connection. That is, a client invoker on
          the server side communicates with a server invoker on the client side
          (in the case of push callbacks - again, see Section <xref
          linkend="section-callbacks"/>). When a callback connection is created,
          all of the configuration information passed to the server side
          <classname>Connector</classname> is passed on to the server side
          callback client invoker. It follows that callback client invokers are
          configured by way of the server side
          <classname>Connector</classname>.
        </para>
      
      </section>
    </section>

    <section>
      <title>Client side configuration</title>

      <para>Invoker configuration on the client side parallels configuration
      on the server side, with the exception that (1) it operates in a simpler
      environment (in particular, it does not assume the presence of an
      MBeanServer) and (2) it does not support a declarative option. However,
      it does support versions of the first three server side programmatic
      options, with the <classname>Client</classname> class playing the
      central role played by the <classname>Connector</classname> class on the
      server side.</para>

      <para>Again, the most straightforward form of configuration is to put
      the configuration parameters on the
      <classname>InvokerLocator</classname>. For example, the fragment</para>

      <programlisting>String locatorURI = "socket://test.somedomain.com:8084";
String params = "/?clientMaxPoolSize=10&amp;timeout=360000";
locatorURI += params;
InvokerLocator locator = new InvokerLocator(locatorURI);
Client client = new Client(locator);
client.connect();</programlisting>

      <para>creates a <classname>Client</classname> using the socket transport
      to connect to a server on host test.somedomain.com, listening on port
      8084. It also passes in two parameters, "clientMaxPoolSize" and
      "timeout", that will be used by the client invoker.</para>

      <para>It is also possible to use configuration maps on the client side.
      The following code fragment accomplishes all that the previous fragment
      does, but it passes one parameter by way of the
      <classname>InvokerLocator</classname> and passes the other by way of a
      configuration map. It also passes in a non-string object, a
      <classname>SocketFactory</classname>:</para>

      <programlisting>String locatorURI = "socket://test.somedomain.com:8084";
String params = "/?clientMaxPoolSize=10";
locatorURI += params;
InvokerLocator locator = new InvokerLocator(locatorURI);
HashMap config = new HashMap();
config.put(ServerInvoker.TIMEOUT, "360000");
config.put(Remoting.CUSTOM_SOCKET_FACTORY, new MySocketFactory());
Client client = new Client(locator, config);
client.connect();</programlisting>

      <para>Note that the value of <code>ServerInvoker.TIMEOUT</code> is
      "timeout", and the value of <code>Remoting.CUSTOM_SOCKET_FACTORY</code>
      is "customSocketFactory". These configuration map keys are discussed
      throughout the chapter and accumulated in section <xref
      linkend="section-configuration-by-properties" />. Also, socket factory configuration
      is covered in <xref linkend="section-socket-factories" />.</para>

      <para>Finally, a third programmatic option is available for those
      configuration properties which happen to be settable client invoker
      properties. In the following fragment, the client invoker is obtained
      from the <classname>Client</classname> and a
      <classname>SocketFactory</classname> is passed to it by way of a setter
      method:</para>

      <programlisting>String locatorURI = "socket://test.somedomain.com:8084";
String params = "/?clientMaxPoolSize=10";
locatorURI += params;
InvokerLocator locator = new InvokerLocator(locatorURI);
HashMap config = new HashMap();
config.put(ServerInvoker.TIMEOUT, "360000");
Client client = new Client(locator, config);
client.connect();
SocketFactory sf = new MySocketFactory();
ClientInvoker clientInvoker = client.getInvoker();
clientInvoker.setSocketFactory(sf);
      </programlisting>

      <para><emphasis role="bold">Note.</emphasis> The
      <classname>Client</classname> creates the client invoker during the call
      to <methodname>Client.connect()</methodname>, so this option only works
      after that method has been called.</para>
      
      <para><emphasis role="bold">Note.</emphasis> Preference is given to values
      in the <classname>InvokerLocator</classname>.  For example, in</para>
      
      <programlisting>String locatorURI = "socket://test.somedomain.com:8084/?clientMaxPoolSize=10";
InvokerLocator locator = new InvokerLocator(locatorURI);
HashMap config = new HashMap();
config.put("clientMaxPoolSize", "20");
Client client = new Client(locator, config);
      </programlisting>
      
      <para>the value of the variable <code>clientMaxPoolSize</code> would be set to 10.
      As of release 2.5.2, that behavior can be reversed by setting the parameter
      <code>org.jboss.remoting.Remoting.CONFIG_OVERRIDES_LOCATOR</code> (actual
      value "configOverridesLocator") to true.  As always, in determining the
      value of the variable <code>configOverridesLocator</code>, preference is
      given to the <classname>InvokerLocator</classname>.  But if the value of
      "configOverridesLocator" is set to true in the <classname>InvokerLocator</classname>,
      or if "configOverridesLocator" is absent from the 
      <classname>InvokerLocator</classname> but it is set to "true" in
      the configuration map, then preference will be given to values in
      the configuration map.  For example, in</para>

      <programlisting>String locatorURI = "socket://test.somedomain.com:8084/?clientMaxPoolSize=10";
InvokerLocator locator = new InvokerLocator(locatorURI);
HashMap config = new HashMap();
config.put("clientMaxPoolSize", "20");
config.put("configOverridesLocator", "true");
Client client = new Client(locator, config);
      </programlisting>
      
      <para>the value of the variable <code>clientMaxPoolSize</code> would be set to 20.</para>
      
    </section>
  </section>
  
  <section>
    <title>Handlers</title>

    <para>Handlers are classes that the invocation is given to on the server
    side (the final target for remoting invocations). To implement a handler,
    all that is needed is to implement the
    <code>org.jboss.remoting.ServerInvocationHandler</code> interface. There
    are a two ways in which to register a handler with a Connector. The first
    is to do it programmatically. The second is via service configuration. For
    registering programmatically, can either pass the ServerInvocationHandler
    reference itself or an ObjectName for the ServerInvocationHandler (in the
    case that it is an MBean). To pass the handler reference directly, call
    <code>Connector::addInvocationHandler(String subsystem,
    ServerInvocationHandler handler)</code>. For example (from
    <code>org.jboss.remoting.samples.simple.SimpleServer</code>):</para>

    <programlisting>InvokerLocator locator = new InvokerLocator(locatorURI);
Connector connector = new Connector();
connector.setInvokerLocator(locator.getLocatorURI());
connector.create();

SampleInvocationHandler invocationHandler = new SampleInvocationHandler();
// first parameter is sub-system name. can be any String value.
connector.addInvocationHandler("sample", invocationHandler);

connector.start();</programlisting>

    <para>To pass the handler by ObjectName, call
    <code>Connector::addInvocationHandler(String subsystem, ObjectName
    handlerObjectName)</code> . For example (from
    <code>org.jboss.test.remoting.handler.mbean.ServerTest</code>):</para>

    <programlisting>MBeanServer server = MBeanServerFactory.createMBeanServer();
InvokerLocator locator = new InvokerLocator(locatorURI);
Connector connector = new Connector();
connector.setInvokerLocator(locator.getLocatorURI());
connector.start();

server.registerMBean(connector, new ObjectName("test:type=connector,transport=socket"));

// now create Mbean handler and register with mbean server
MBeanHandler handler = new MBeanHandler();
ObjectName objName = new ObjectName("test:type=handler");
server.registerMBean(handler, objName);

connector.addInvocationHandler("test", objName);</programlisting>

    <para>Is important to note that if not starting the Connector via the
    service configuration, will need to explicitly register it with the
    MBeanServer (will throw exception otherwise).</para>

    <para>If using a service configuration for starting the Connector and
    registering handlers, can either specify the fully qualified class name
    for the handler, which will instantiate the handler instance upon startup
    (which requires there be a void parameter constructor), such as:</para>

    <programlisting>&lt;handlers&gt;
   &lt;handler subsystem="mock"&gt;
      org.jboss.remoting.transport.mock.MockServerInvocationHandler
   &lt;/handler&gt;
&lt;/handlers&gt;</programlisting>

    <para>where MockServerInvocationHandler will be constructed upon startup
    and registered with the Connector as a handler.</para>

    <para>Can also use an ObjectName to specify the handler. The configuration
    is the same, but instead of specifying a fully qualified class name, you
    specify the ObjectName for the handler, such as (can see
    <code>mbeanhandler-service.xml</code> under remoting tests for full
    example):</para>

    <programlisting>&lt;handlers&gt;
   &lt;handler subsystem="mock"&gt;test:type=handler&lt;/handler&gt;
&lt;/handlers&gt;</programlisting>

    <para>The only requirement for this configuration is that the handler
    MBean must already be created and registered with the MBeanServer at the
    point the Connector is started.</para>

    <bridgehead>Handler implementations</bridgehead>

    <para>The Connectors will maintain a reference to the handler instances
    provided (either indirectly via the MBean proxy or directly via the
    instance object reference). For each request to the server invoker, the
    handler will be called upon. Since the server invokers can be
    multi-threaded (and in most cases would be), this means that the handler
    may receive concurrent calls to handle invocations. Therefore, handler
    implementations should take care to be thread safe in their
    implementations.</para>

    <bridgehead>Stream handler</bridgehead>

    <para>There is also an invocation handler interface that extends the
    ServerInvocationHandler interface specifically for handling of input
    streams as well as normal invocations. See the section on sending streams
    for further details. As for Connector configuration, it is the
    same.</para>

    <bridgehead>HTTP handlers</bridgehead>

    <para>Since there is extra information needed when dealing with the http
    transport, such as headers and response codes, special consideration is
    needed by handlers. The handlers receiving http invocations can get and
    set this extra information via the InvocationRequest that is passed to the
    handler.</para>

    <para>Server invoker for the http transport will add the following to the
    InvocationRequest's request payload map:</para>

    <para><emphasis role="bold">MethodType</emphasis> - the http request type
    (i.e., GET, POST, PUT, HEADER, OPTIONS). Can use the contant value
    HTTPMetadataConstants.METHODTYPE, if don't want to use the actual string
    'MethodType' as the key to the request payload map.</para>

    <para><emphasis role="bold">Path</emphasis> - the url path. Can use the
    contant value HTTPMetadataConstants.PATH, if don't want to use the actual
    string 'Path' as the key to the request payload map.</para>

    <para><emphasis role="bold">HttpVersion</emphasis> - the client's http
    version. Can use the contant value HTTPMetadataConstants.HTTPVERSION, if
    don't want to use the actual string 'HttpVersion' as the key to the
    request payload map.</para>

    <para>Other properties from the original http request will also be
    included in the request payload map, such as request headers. Can
    reference
    org.jboss.test.remoting.transport.http.method.MethodInvocationHandler as
    an example for pulling request properties from the
    InvocationRequest.</para>

    <para>The only time this will not be added is a POST request where an
    InvocationRequest is passed and is not binary content type
    (application/octet-stream).</para>

    <para>The handlers receiving http invocations can also set the response
    code, response message, response headers, and content-type. To do this, will
    need to get the return payload map from the InvocationRequest passed (via its
    getReturnPayload() method). Then populate this map with whatever
    properties needed. For response code and message, will need to use the
    following keys for the map:</para>

    <para><emphasis role="bold">ResponseCode</emphasis> - Can use the constant
    value HTTPMetaDataConstants.RESPONSE_CODE, if don't want to use the actual
    string 'ResponseCode' as they key. <emphasis
    role="bold">IMPORTANT</emphasis> - The value put into map for this key
    MUST be of type java.lang.Integer.</para>

    <para><emphasis role="bold">ResponseCodeMessage</emphasis> - Can use the
    constant value HTTPMetadataConstants.RESPONSE_CODE_MESSAGE, if don't want
    to use the actual string 'ResponseCodeMessage' as the key. The value put
    into map for this key should be of type java.lang.String.</para>

    <para>Is also important to note that ALL http requests will be passed to
    the handler. So even OPTIONS, HEAD, and PUT method requests will need to
    be handled. So, for example, if want to accept OPTIONS method requests,
    would need to populate response map with key of 'Allow' and value of
    'OPTIONS, POST, GET, HEAD, PUT', in order to tell calling client that all
    these method types are allowed. Can see an example of how to do this
    within
    org.jboss.test.remoting.transport.http.method.MethodInvocationHandler.</para>

    <para>The PUT request will be handled the same as a POST method request
    and the PUT request payload will be included within the InvocationRequest
    passed to the server handler. It is up to the server handler to set the
    proper resonse code (or throw proper exception) for the processing of the
    PUT request. See <ulink
    url="http://www.ietf.org/rfc/rfc2616.txt?number=2616">
    http://www.ietf.org/rfc/rfc2616.txt?number=2616 </ulink>, section 9.6 for
    details on response codes and error responses).</para>

    <bridgehead>HTTP Client</bridgehead>

    <para>The HttpClientInvoker will now put the return from HttpURLConnection
    getHeaderFields() method into the metadata map passed to the Client's
    invoke() method (if not null). This means that if the caller passes a
    non-null Map, it can then get the response headers. It is important to
    note that each response header field key in the metadata map is associated
    with a list of response header values, so to get a value, would need code
    similar to:</para>

    <programlisting>Object response = remotingClient.invoke((Object) null, metadata); 
String allowValue = (String) ((List) metadata.get("Allow").get(0);
</programlisting>

    <para>Can reference
    org.jboss.test.remoting.transport.http.method.HTTPInvokerTestClient for an
    example of this.</para>

    <para>Note that when making a http request using the OPTIONS method type,
    the return from the Client's invoke() method will ALWAYS be null.</para>

    <para>Also, if the response code is 400, the response returned will be
    that of the error stream and not the standard input stream. So is
    important to check for the response code.</para>

    <para>Two values that will always be set within the metadata map passed to
    the Client's invoke() method (when not null), is the response code and
    response message from the server. These can be found using the
    keys:</para>

    <para><emphasis role="bold">ResponseCode</emphasis> - Can use the constant
    value HTTPMetaDataConstants.RESPONSE_CODE, if don't want to use the actual
    string 'ResponseCode' as the key. <emphasis
    role="bold">IMPORTANT</emphasis> - The value returned for this key will be
    of type java.lang.Integer.</para>

    <para><emphasis role="bold">ResponseCodeMessage</emphasis> - Can use the
    constant value from HTTPMetadataConstants.RESPONSE_CODE_MESSAGE, if don't
    want to use the actual string 'ResponseCodeMessage' as the key. The value
    returned for this key will be of type java.lang.String.</para>

    <para>An example of getting the response code can be found within
    org.jboss.test.remoting.transport.http.method.HTTPInvokerTestClient.</para>
  </section>

  <section>
    <title>Discovery (Detectors)</title>

    <bridgehead>Domains</bridgehead>

    <para>Detectors have the ability to accept multiple domains. What domains
    that the detector will accept as viewable can either be set
    programmatically via the method:</para>

    <para><code>public void setConfiguration(org.w3c.dom.Element xml)
    </code></para>

    <para>or by adding to jboss-service.xml configuration for the detector.
    The domains that the detector is currently accepting can be retrieved from
    the method:</para>

    <para><code>public org.w3c.dom.Element getConfiguration()</code></para>

    <para>The configuration xml is a MBean attribute of the detector, so can
    be set or retrieved via JMX.</para>

    <para>There are three possible options for setting up the domains that a
    detector will accept. The first is to not call the
    <code>setConfiguration()</code> method (or just not add the configuration
    attribute to the service xml). This will cause the detector to use only
    its domain and is the default behavior. This enables it to be backwards
    compatible with earlier versions of JBoss Remoting (JBoss 4, DR2 and
    before).</para>

    <para>The second is to call the <code>setConfiguration()</code> method (or
    add the configuration attribute to the service xml) with the following xml
    element:</para>

    <programlisting>&lt;domains&gt;
   &lt;domain&gt;domain1&lt;/domain&gt;
   &lt;domain&gt;domain2&lt;/domain&gt;
&lt;/domains&gt;</programlisting>

    <para>where <code>domain1</code> and <code>domain2</code> are the two
    domains you would like the detector to accept. This will cause the
    detector to accept detections only from the domains specified, and no
    others.</para>

    <para>The third and final option is to call the setConfiguration() method
    (or add the configuration attribute to the service xml) with the following
    xml element:</para>

    <programlisting>&lt;domains&gt;
&lt;/domains&gt;</programlisting>

    <para>This will cause the detector to accept all detections from any
    domain.</para>

    <para>By default, remoting detection will ignore any detection message the
    it receives from a server invoker running within its own jvm. To disable
    this, add an element called 'local' to the detector configuration
    (alongside the domain element) to indicate should accept detection
    messages from local server invokers. This will be false by default, so
    maintains the same behavior as previous releases. For example:</para>

    <programlisting>&lt;domains&gt;
   &lt;domain&gt;domain1&lt;/domain&gt;
   &lt;domain&gt;domain2&lt;/domain&gt;
&lt;/domains&gt;
&lt;local/&gt;</programlisting>

    <para>An example entry of a Multicast detector in the jboss-service.xml
    that accepts detections only from the roxanne and sparky domains using
    port 5555, including servers in the same jvm, is as follows:</para>

    <programlisting>&lt;mbean code="org.jboss.remoting.detection.multicast.MulticastDetector"
       name="jboss.remoting:service=Detector,transport=multicast"&gt;
   &lt;attribute name="Port"&gt;5555&lt;/attribute&gt;
   &lt;attribute name="Configuration"&gt;
      &lt;domains&gt;
         &lt;domain&gt;roxanne&lt;/domain&gt;
         &lt;domain&gt;sparky&lt;/domain&gt;
      &lt;/domains&gt;
      &lt;local/&gt;
   &lt;/attribute&gt;
&lt;/mbean&gt;</programlisting>

    <bridgehead>Global Detector Configuration</bridgehead>

    <para>The following are configuration attributes for all the remoting
    detectors.</para>

    <para><emphasis role="bold">DefaultTimeDelay</emphasis> - amount of time,
    in milliseconds, which can elapse without receiving a detection event
    before suspecting that a server is dead and performing an explicit
    invocation on it to verify it is alive. If this invocation, or ping,
    fails, the server will be removed from the network registry. The default
    is 5000 milliseconds.</para>

    <para><emphasis role="bold">HeartbeatTimeDelay</emphasis> - amount of time
    to wait between sending (and sometimes receiving) detection messages. The
    default is 1000 milliseconds.</para>

    <bridgehead>JNDIDetector</bridgehead>

    <para><emphasis role="bold">Port</emphasis> - port to which detector will
    connect for the JNDI server.</para>

    <para><emphasis role="bold">Host</emphasis> - host to which the detector
    will connect for the JNDI server.</para>

    <para><emphasis role="bold">ContextFactory</emphasis> - context factory
    string used when connecting to the JNDI server. The default is
    <code>org.jnp.interfaces.NamingContextFactory</code> .</para>

    <para><emphasis role="bold">URLPackage</emphasis> - url package string to
    use when connecting to the JNDI server. The default is
    <code>org.jboss.naming:org.jnp.interfaces</code> .</para>

    <para><emphasis role="bold">CleanDetectionNumber</emphasis> - Sets the
    number of detection iterations before manually pinging remote server to
    make sure still alive. This is needed since remote server could crash and
    yet still have an entry in the JNDI server, thus making it appear that it
    is still there. The default value is 5.</para>

    <para>Can either set these programmatically using setter method or as
    attribute within the remoting-service.xml (or anywhere else the service is
    defined). For example:</para>

    <programlisting>&lt;mbean code="org.jboss.remoting.detection.jndi.JNDIDetector"
       name="jboss.remoting:service=Detector,transport=jndi"&gt;
   &lt;attribute name="Host"&gt;localhost&lt;/attribute&gt;
   &lt;attribute name="Port"&gt;5555&lt;/attribute&gt;
&lt;/mbean&gt;</programlisting>

    <para>If the JNDIDetector is started without the Host attribute being set,
    it will try to start a local JNP instance (the JBoss JNDI server
    implementation) on port 1088.</para>

    <bridgehead>MulticastDetector</bridgehead>

    <para><emphasis role="bold">DefaultIP</emphasis> - The IP that is used to
    broadcast detection messages on via multicast. To be more specific, will
    be the ip of the multicast group the detector will join. This attribute is
    ignored if the Address has already been set when started. Default is
    224.1.9.1.</para>

    <para><emphasis role="bold">Port</emphasis> - The port that is used to
    broadcast detection messages on via multicast. Default is 2410.</para>

    <para><emphasis role="bold">BindAddress</emphasis> - The address to bind
    to for the network interface.</para>

    <para><emphasis role="bold">Address</emphasis> - The IP of the multicast
    group that the detector will join. The default will be that of the
    DefaultIP if not explicitly set.</para>
    
    <para><emphasis role="bold">BufferSize</emphasis> - The size of the buffer used
    by the MulticastSocket. The default is 10000.</para>

    <para>If any of these are set programmatically, need to be done before the
    detector is started (otherwise will use default values).</para>
  </section>

  <section>
     <title>Transports (Invokers)</title>

     <para>This section covers configuration issues for each of the transports,
     beginning with material that applies to all transports. The
     material in a later section in this chapter, <xref
     linkend="section-socket-factories" />, also applies to all
     transports.</para>
    
  <section>
     <title>Features introduced in Remoting version 2.4</title>

     <para>A number of transport independent features are introduced in Remoting
     version 2.4.</para>
    
     <section>
        <title>Binding to 0.0.0.0</title>
        
        <para>Before version 2.4, a Remoting server could bind to only one
        specific IP address. In particular, the address 0.0.0.0 was translated
        to the host returned by <code>java.net.InetAddress.getLocalHost()</code>
        (or its equivalent IP address). As of version 2.4 [and later releases in
        the 2.2 series], a server started with the address 0.0.0.0 binds to
        all available interfaces.</para>
        
        <para><emphasis role="bold">Note.</emphasis> If 0.0.0.0 appears in the
        <classname>InvokerLocator</classname>, it needs to be translated to an
        address that is usable on the client side. If the system property
        <code>InvokerLocator.BIND_BY_HOST</code> (actual value
        "remoting.bind_by_host") is set to "true", the
        <classname>InvokerLocator</classname> host will be transformed to the
        value returned by
        <code>InetAddress.getLocalHost().getHostName()</code>.
        Otherwise, it will be transformed to the value returned by
        <code>InetAddress.getLocalHost().getHostAddress()</code>. </para>
        
      </section>
      
      <section>
        <title>Multihome servers</title>
        
        <para>As of release 2.4, besides binding to <emphasis>all</emphasis>
        available interfaces, it is also possible to configure a server to
        bind to a subset of the interfaces available on a given host. Suppose,
        for example, that a host machine has NICs configured with addresses
        10.32.4.2, 192.168.4.2, and 192.168.8.2, and suppose that 192.168.8.2 is
        on a LAN from which access is meant to be denied. It is now possible to
        create a single server that binds to 10.32.4.2 and 192.168.4.2.</para>
        
        <para>It would be convenient to be able to create an <classname>InvokerLocator</classname>
        that looks something like:</para>
        
        <programlisting>socket://10.32.4.2&amp;192.168.4.2:6500</programlisting>
        
        <para>but, unfortunately, that violates the URI syntax. Instead, a special
        placeholder, "multihome", is used in the host position, and the actual host
        addresses are given in the query component, e.g.,</para>
        
        <programlisting>socket://multihome/?homes=10.32.4.2:6500!192.168.4.2:6500</programlisting>
        
        <para>An abbreviated syntax allows factoring out the bind port:</para>
        
        <programlisting>socket://multihome:6500/?homes=10.32.4.2!192.168.4.2</programlisting>
        
        <para>The value in the port position is treated as a default value which can be
        overriden in the "homes" parameter:</para>
        
        <programlisting>socket://multihome:6500/?homes=10.32.4.2!192.168.4.2:6501</programlisting>
        
        <para>binds to 10.32.4.2:6500 and 192.168.4.2:6501.</para>
        
        <para>In the presence of a NAT router, it may be necessary for the client to
        connect to addresses different than the bind addresses, and a set of connect
        addresses may be specified with a "connecthomes" parameter:</para>
        
        <programlisting>socket://multihome/?homes=10.32.4.2:6500!192.168.4.2:6501
       &amp;connecthomes=10.32.42.2:7500!192.168.42.2:7501</programlisting>
     
        <para>specifies a server that binds to 10.32.4.2:6500 and 192.168.4.2:6501,
        as before, but now a client connects to it using the addresses
        10.32.42.2:7500 and 192.168.42.2:7501.</para>
        
        <para>Multihome servers may be configured, also, in *-service.xml MBean
        files and *-beans.xml POJO files. The following MBean definition is
        equivalent to the preceding locator:</para>
        
        <programlisting>&lt;mbean code="org.jboss.remoting.transport.Connector"
       name="jboss.remoting:service=Connector,transport=Socket"
       display-name="Socket transport Connector"&gt;
    
   &lt;attribute name="Configuration"&gt;
      &lt;config&gt;
         &lt;invoker transport="socket"&gt;
            <emphasis role="bold">
            &lt;attribute name="homes"&gt;
               &lt;home&gt;10.32.4.2:6500&lt;/home&gt;
               &lt;home&gt;192.168.4.2:6501&lt;/home&gt;
            &lt;/attribute&gt;
            &lt;attribute name="connecthomes"&gt;
               &lt;connecthome&gt;10.32.42.2:7500&lt;/connecthome&gt;
               &lt;connecthome&gt;192.168.42.2:7501&lt;/connecthome&gt;
            &lt;/attribute&gt;
            </emphasis>
         &lt;/invoker&gt;
         &lt;handlers&gt;
            ...
         &lt;/handlers&gt;
      &lt;/config&gt;
   &lt;/attribute&gt;
&lt;/mbean&gt;</programlisting>
        
        <para>The "serverBindPort" and "clientConnectPort" attributes may be used to
        give default values for bind ports and connect ports, respectively.</para>
    
        <para>The same server may be configured with the
        <classname>org.jboss.remoting.ServerInvocation</classname> object as well.
        For example,</para>    
        <programlisting>Connector connector = new Connector();
         
// Create ServerConfiguration object for socket transport
ServerConfiguration serverConfig = new ServerConfiguration("socket");
            
// Add invokerLocatorParameters (applicable to client and server)
Map locatorConfig = new HashMap();
<emphasis role="bold">
locatorConfig.put("homes", "10.32.4.2:6500!192.168.4.2:6501");
locatorConfig.put("connecthomes", "10.32.42.2:7500!192.168.42.2:7501");
</emphasis>
serverConfig.setInvokerLocatorParameters(locatorConfig);
                   
// Add invocation handlers
...
             
connector.setServerConfiguration(serverConfig);
connector.create();
connector.start();</programlisting>
              
        <para>is equivalent to the preceding MBean definition.</para>
        
        <para><emphasis role="bold">Note.</emphasis> The Strings "homes" and
        "connecthomes" are available as constants in the
        <classname>InvokerLocator</classname> class:
        <code>InvokerLocator.HOMES_KEY</code> and
        <code>InvokerLocator.CONNECT_HOMES_KEY</code>.</para>
      </section>
      
      <section>
         <title>Socket creation listeners</title>
         
         <para>Sometimes it is useful to be able to grab a socket right after it
         has been created to either apply some additional configuration or
         retrieve some information. It is possible to configure Remoting with
         instantions of the interface
         <classname>org.jboss.remoting.socketfactory.SocketCreationListener</classname>
         </para>
         
         <programlisting>public interface SocketCreationListener
{
   /**
    * Called when a socket has been created.
    * 
    * @param socket socket that has been created
    * @param source SocketFactory or ServerSocket that created the socket
    * @throws IOException
    */
   void socketCreated(Socket socket, Object source) throws IOException;
}</programlisting>
         
         <para>Socket creation listeners can be configured through the use of
         the keys
         <code>org.jboss.remoting.Remoting.SOCKET_CREATION_CLIENT_LISTENER</code>
         (actual value "socketCreationClientListener") and
         <code>org.jboss.remoting.Remoting.SOCKET_CREATION_SERVER_LISTENER</code>
         (actual value "socketCreationServerListener"), which install listeners
         for <code>javax.net.SocketFactory</code>s and
         <code>java.net.ServerSocket</code>s, respectively. The value associated
         with these keys may be (1) an object that implements
         <classname>SocketCreationListener</classname> or (2) a string that
         names a class that implements
         <classname>SocketCreationListener</classname>. In the latter case, the
         default constructor will be used to create an object of the designated
         class.</para>
      </section>
      
      <section>
         <title>Making client IP address available to application</title>
        
         <para>All of the transports (bisocket, sslbisocket, http, https, rmi,
         sslrmi, servlet, sslservlet, socket, and sslsocket) capture the IP
         address of the client side of a TCP connection from client to server
         and make it available to application code on both the client side and
         server side. On the client side, the method
         <methodname>org.jboss.remoting.Client.getAddressSeenByServer()</methodname>,
         with signature</para>
         
         <programlisting>public InetAddress getAddressSeenByServer() throws Throwable</programlisting>
         
         <para>returns the IP address of the client as seen by the server. On
         the server side, the same IP address is placed in the request payload
         map held by the
         <classname>org.jboss.remoting.InvocationRequest</classname>. It may be
         retrieved by the
         <classname>org.jboss.remoting.ServerInvocationHandler</classname> as
         follows:</para>
         
         <programlisting>public Object invoke(InvocationRequest invocation throws Throwable
{
   ...
   InetAddress address = invocation.getRequestPayload().get(Remoting.CLIENT_ADDRESS);
   ...
}</programlisting>
      </section>
      
      <section>
         <title>Support for IPv6 addresses</title>
         
         <para><classname>org.jboss.remoting.InvokerLocator</classname> will now
         accept IPv6 IP addresses. For example,</para>
         
         <programlisting>socket://[::1]:3333/?timeout=10000
socket://[::]:4444/?timeout=10000
socket://[::ffff:127.0.0.1]:5555/?timeout=10000
socket://[fe80::205:9aff:fe3c:7800%7]:6666/?timeout=10000
socket://multihome/?homes=[fe80::205:9aff:fe3c:7800%7]:7777![fe80::214:22ff:feef:68bb%4]:8888</programlisting>
      </section>
      
      <section>
         <title>Delayed destruction of client invokers</title>
         
         <para>Multiple clients may share a single client invoker.  For example, in the code</para>
         
         <programlisting>InvokerLocator locator = new InvokerLocator("socket://127.0.0.1:5555");
Client client1 = new Client(locator);
Client client2 = new Client(locator);</programlisting>
         
         <para><code>client1</code> and <code>client2</code> will both
         communicate with the server through a single
         <classname>org.jboss.remoting.transport.socket.MicroSocketClientInvoker</classname>.
         The number of <classname>Client</classname>s using a single client
         invoker is tracked, and the invoker is destroyed when the count goes to
         zero. It may be useful to delay the destruction of the invoker when it
         is known that another <classname>Client</classname> will want to use it
         in the near future. The delayed destruction of a client invoker may be
         achieved through the use of the key
         <code>Client.INVOKER_DESTRUCTION_DELAY</code> (actual value
         "invokerDestructionDelay").  For example,</para>
         
         <programlisting>InvokerLocator locator =
        new InvokerLocator("socket://127.0.0.1:5555/?invokerDestructionDelay=5000");
Client client = new Client(locator);
client.connect();
...
client.disconnect();</programlisting>
         
         <para>will cause <code>client</code> to delay the destruction of its
         client invoker (assuming <code>client</code> is the only user), by 5000
         milliseconds. Of course, "invokerDestructionDelay" may be passed to the
         <classname>Client</classname> by way of a configuration map, as
         well.</para>
         
       </section>
    </section>
    
    <section>
      <title>Server Invokers</title>

      <para>The following configuration properties are common to all the
      current server invokers.</para>

      <para><emphasis role="bold">serverBindAddress</emphasis> - The address
      on which the server binds to listen for requests. The default is an
      empty value which indicates the server should be bound to the host
      provided by the locator url, or if this value is null, the local host as
      provided by <code>InetAddress.getLocalHost()</code> .</para>

      <para><emphasis role="bold">serverBindPort</emphasis> - The port to
      listen for requests on. A value of 0 or less indicates that a free
      anonymous port should be chosen.</para>

      <para><emphasis role="bold">maxNumThreadsOneway</emphasis> - specifies
      the maximum number of threads to be used within the thread pool for
      accepting one way invocations on the server side. This property will
      only be used in the case that the default thread pool is used. If a
      custom thread pool is set, this property will have no meaning. This
      property can also be retrieved or set programmatically via the
      <code>MaxNumberOfOnewayThreads</code> property.</para>

      <para><emphasis role="bold">onewayThreadPool</emphasis> - specifies
      either the fully qualified class name for a class that implements the
      <code>org.jboss.util.threadpool.ThreadPool</code> interface or the JMX
      ObjectName for an MBean that implements the
      <code>org.jboss.util.threadpool.ThreadPool</code> interface. This will
      replace the default
      <code>org.jboss.util.threadpool.BasicThreadPool</code> used by the
      server invoker.</para>

      <para>Note that this value will NOT be retrieved until the first one-way
      (server side) invocation is made. So if the configuration is invalid,
      will not be detected until this first call is made. The thread pool can
      also be accessed or set via the <code>OnewayThreadPool</code> property
      programmatically.</para>

      <para>Important to note that the default thread pool used for the
      one-way invocations on the server side will block the calling thread if
      all the threads in the pool are in use until one is released.</para>
    </section>

    <section>
      <title>Configurations affecting the invoker client</title>

      <para>There are some configurations which will impact the invoker
      client. These will be communicated to the client invoker via parameters
      in the Locator URI. These configurations can not be changed during
      runtime, so can only be set up upon initial configuration of the server
      invoker on the server side. The following is a list of these and their
      effects.</para>

      <para><emphasis role="bold">clientConnectPort</emphasis> - the port the
      client will use to connect to the remoting server. This would be needed
      in the case that the client will be going through a router that forwards
      requests made externally to a different port internally.</para>

      <para><emphasis role="bold">clientConnectAddress</emphasis> - the ip or
      hostname the client will use to connect to the remoting server. This
      would be needed in the case that the client will be going through a
      router that forwards requests made externally to a different ip or host
      internally.</para>

      <para>If no client connect address or server bind address specified,
      will use the local host's address (via
      <code>InetAddress.getLocalHost().getHostAddress()</code> ).</para>
      
      <para><emphasis role="bold">Note</emphasis> The role played by "clientConnectAddress"
      and "clientConnectPort" deserves some further elaboration.  When a server
      is set up, it is either given an <classname>InvokerLocator</classname> explicitly,
      or it is given enough information in an MBean XML file or a
      <classname>ServerConfiguration</classname> POJO from which to construct an
      <classname>InvokerLocator</classname>, and a client uses the host field and
      port field in the <classname>InvokerLocator</classname> to determine how to connect to
      the server.  It follows that if an explicit <classname>InvokerLocator</classname>
      is passed to the server, then the host and port fields are either given explicitly
      or are generated, so there is no need for "clientConnectAddress" or "clientConnectPort"
      fields.  However, if the server is configured by way of an MBean XML file or
      a <classname>ServerConfiguration</classname>, and no explicit 
      <classname>InvokerLocator</classname> is specified, then the "clientConnectAddress"
      and "clientConnectPort" parameters can be used to specify the host and port
      fields in the <classname>InvokerLocator</classname>.  If they are omitted, then
      the host and port fields will be derived from the values of the "serverBindAddress"
      and "serverBindPort" parameters (or generated, if those fields are omitted).
      Therefore, there is a role for the "clientConnectAddress" and "clientConnectPort"
      parameters <emphasis role="bold">only if</emphasis> clients are meant to connect
      to a host and port different than the bind host and bind port.  Such a situation
      might occur in the presence of a translating firewall between the client and the
      server.</para>
    </section>

    <section>
      <title>How the server bind address and port is determined</title>

      <para>If the serverBindAddress property is set, the server invoker will
      bind to that address.  Otherwise, it will, with one exception, use the
      address in the InvokerLocator (if there is one).  The exception is the
      case in which the clientConnectAddress property is set, which indicates
      that the adddess in the InvokerLocator is not the real address of the
      server's host.  In that case, and in the case that there is no address
      in the InvokerLocator, the server will bind to the address of the local
      host, as determined by the call</para>
      
      <programlisting>InetAddress.getLocalHost().getHostAddress();</programlisting>
      
      <para>In other words, the logic is</para>
      <programlisting>if (serverBindAddress is set)
   use it
else if (the host is present in the InvokerLocator and clientConnectAddress is not set)
   use host from InvokerLocator
else
   use local host address</programlisting>
                                                                                                     
      <!--para>There is one other exception.  If the InvokerLocator address is
      0.0.0.0 and the system property called 'remoting.bind_by_host' is set to
      true, then the local host name will be used, as determined by the call</para>
      
      <programlisting>InetAddress.getLocalHost().getHostName();</programlisting>
      
      <para>If 'remoting.bind_by_host' is set to false, then local host address will
      be used.  To facilitate setting this property, the following static variable is
      defined in <classname>InvokerLocator</classname>:</para>

      <programlisting>
         public static final String BIND_BY_HOST = "remoting.bind_by_host";
      </programlisting-->

      <para>If the serverBindPort property is set, it will be used. If this
      value is 0 or a negative number, then the next available port will be
      found and used. If the serverBindPort property is not set, but the
      clientConnectPort property is set, then the next available port will be
      found and used. If neither the serverBindPort nor the clientConnectPort
      is set, then the port specified in the original InvokerLocator will be
      used. If this is 0 or a negative number, then the next available port
      will be found and used. In the case that the next available port is used
      because either the serverBindPort or the original InvokerLocator port
      value was either 0 or negative, the InvokerLocator will be updated to
      reflect the new port value.</para>
      
      <para><emphasis role="bold">Note.</emphasis> 
      In the case that a bind port isn't specified, the utility class
      <classname>org.jboss.remoting.transport.PortUtil</classname> is used to 
      supply an available port.  By default, it will look for a port in the range
      1024 to 65535, inclusively.  As of release 2.5.2, PortUtil can be configured
      to search a smaller range by setting the values PortUtil.MIN_PORT (actual
      value "minPort") and / or PortUtil.MAX_PORT (actual value "maxPort") in
      the InvokerLocator, a configuration map, an MBean XML file, or a 
      <classname>ServerConfiguration</classname> object.  The range is static;
      that is, whenever "minPort" or "maxPort" are set, they affect all
      subsequent calls in the JVM.  Note that <classname>PortUtil</classname>
      will apply a new "minPort" value only if it is greater than the current
      value, and it will apply a new "maxPort" value only if it is less than
      the current value.  And it will never apply a new value when the result
      would be such that the value of "maxPort" would be less than the value
      of "minPort".</para> 
    </section>

    <section>
      <title>Socket transport</title>

      <para>The Socket transport is one of the more complicated invokers
      mainly because allows the highest degree of configuration. To better
      understand how changes to configuration properties for the Socket
      invoker (both client and server) will impact performance and
      scalability, will discuss the implementation and how it works in
      detail.</para>
        
      <section>
        <title>How the Socket transport works</title>

        <bridgehead><emphasis role="bold">Server</emphasis></bridgehead>

        <para>When the socket server invoker is started, it will create one, and
        only one, instance of <classname>java.net.ServerSocket</classname> for
        each configured bind address. Typically there would exactly one
        <classname>ServerSocket</classname>, but there would be more than one
        for a mltihome server with multiple bind addresses. Upon being started,
        it will also create and start a number of threads to be used for
        accepting incoming requests from the ServerSocket. These threads are
        called the accept threads and the number of them created is controlled
        by the "numAcceptThreads" property. If "numAcceptThreads" is set to "n"
        (it defaults to 1), there will be "n" accept threads per
        <classname>ServerSocket</classname>. When these accept threads are
        started, they will call accept() on the ServerSocket and block until the
        ServerSocket receives a request from a client, where it will return a
        Socket back to the accept thread who called the accept() method. As soon
        as this happens, the accept thread will try to pass off the Socket to
        another thread for processing.</para>
        
        <para>The threads that actually process the incoming request, referred
        to as server threads
        (<classname>org.jboss.remoting.transport.socket.ServerThread</classname>),
        are stored in a pool. The accept thread will try to retrieve the first
        available server thread from the pool and hand off the Socket for
        processing. If the pool does not contain any available server threads
        and the max pool size has not been reached, a new server thread will be
        created for processing. Otherwise, if the max pool size has been
        reached, the accept thread will wait for one to become available (will
        wait until socket timeout has been reached). The size of the server
        thread pool is defined by the 'maxPoolSize' property. As soon as the
        accept thread has been able to hand off the Socket to a server thread
        for processing, it will loop back to ServerSocket and call accept() on
        it again. This will continue until the socket server invoker is
        stopped.</para>

        <para>The server thread processing the request will be the thread of
        execution through the unmarshalling of the data, calling on the server
        invocation handler, and marshalling of response back to the client.
        After the response has been sent, the server thread will then hold the
        socket connection and wait for another request to come from this
        client. It will wait until the socket is closed by the client, a
        socket timeout occurs, or receives another request from the client in
        which to process. When the client socket connection session is closed,
        meaning timeout or client closed socket connection, then the thread
        will return itself to the pool.</para>

        <para>If all the server threads from the pool are in use, meaning have
        a client connection established, and the pool has reached its maximum
        value, the accept threads (no matter how many there are) will have to
        wait until one of the server threads is available for processing. This
        why having a large number of accept threads does not provide any real
        benefit. If all the accept threads are blocked waiting for server
        thread, new client requests will then be queued until it can be
        accepted. The number of requests that can be queued is controlled by
        the "backlog" property and can be useful in managing sudden bursts in
        requests.</para>

        <para>If take an example with a socket server invoker that has max
        pool set to 300, accept threads is 2, and backlog is 200, will be able
        to make 502 concurrent client calls. The 503rd client request will get
        an exception immediately. However, this does not mean all 502 requests
        will be guaranteed to be processed, only the first 300 (as they have
        server threads available to do the processing). If 202 of the server
        threads finish processing their requests from their initial client
        connections and the connection is released before the timeout for the
        other 202 that are waiting (200 for backlog and 2 for accept thread),
        then they will be processed (of course this is a request by request
        determination).</para>

        <para>As of JBossRemoting 2.2.0 release, can also add configuration
        for cleaning up idle server threads using the 'idleTimeout'
        configuration property. Setting this property to a value of greater
        than zero will activate idle timeout checking, which is disabled by
        default. When enabled, the idle timeout checker will periodically
        iterate through the server threads that are active and inactive and if
        have not processed a request within the designated idle timeout
        period, the server thread will be shutdown and removed from
        corresponding pool. Active server threads are ones that have a socket
        connection associated with it and are in a blocked read waiting for
        data from the client. Inactive server threads are ones that have
        finished processing on a particular socket connection and have been
        returned to the thread pool for later reuse. </para>
        
        <para><emphasis role="bold">Note.</emphasis>  A server thread that is
        engaged in a long invocation when the idle timeout checker is activated
        can be removed from its thread pool and marked for later destruction once
        the invocation is complete.  The "idleTimeout" value should be configured
        accordingly.</para>
        
        <para><emphasis role="bold">Note.</emphasis> As of Remoting version 2.4,
        some changes have been made to
        <classname>ServerThread</classname>.</para>
        
        <orderedlist>
          <listitem>
             <para>Once a server thread has completed an invocation, it will try
             to read another invocation instead of returning to the thread pool.
             It follows that the fact that a server thread is not in the thread
             pool does not necessarily indicate that it is busy: it might just
             be blocked in a <methodname>InputStream.read()</methodname>.
             Therefore, when an accept thread needs a server thread and the
             thread pool is empty, it will try to appropriate server threads
             which are not in the thread pool. While a server thread is in the
             middle of processing an invocation, it cannot be interrupted, but
             if it is blocked waiting for the next invocation, it is available
             to be interrupted. However, when the server is busy, it is
             conceivable for an accept thread to grab a server thread and before
             the server thread gets a chance to read an invocation, it gets
             interrupted again by the accept thread. To prevent server threads
             from bouncing around like that, the parameter
             <code>ServerThread.EVICTABILITY_TIMEOUT</code> (actual value
             "evictabilityTimeout) has been introduced. If less than that period
             has elapsed since the server thread has started waiting for the
             next invocation, it will not allow itself to be pre-empted. </para>
          </listitem>
          
          <listitem>
             <para>Prior to version 2.4, if a server thread experienced a
             <classname>java.net.SocketTimeoutException</classname>, it would
             return itself to the thread pool and could not be reused until a
             new socket connection was created for it to use. In principle, it
             would be more efficient for the server thread simply to try again
             to read the next invocation. Unfortunately,
             <classname>java.io.ObjectInputStream</classname> ceases to function
             once it experiences a
             <classname>SocketTimeoutException</classname>. The good news is
             that
             <classname>org.jboss.serial.io.JBossObjectInputStream</classname>,
             made available by the JBossSerialization project, does not suffer
             from that problem. Therefore, when it experiences a
             <classname>SocketTimeoutException</classname>, a server thread will
             check whether it is using a
             <classname>JBossObjectInputStream</classname> or not and act
             accordingly. Just to allow for the possibility that an application
             is using yet another version of
             <classname>ObjectInputStream</classname>, the parameter
             <code>ServerThread.CONTINUE_AFTER_TIMEOUT</code> (actual value
             "continueAfterTimeout") allows the behavior following a
             <classname>SocketTimeoutException</classname> to be configured
             explicitly.</para>
          </listitem>
        </orderedlist>

        <para><emphasis role="bold">Note.</emphasis> When a
        <classname>ServerThread</classname> receives an invocation, it enters a
        synchronized method to prevent itself from being interrupted while it is
        processing the invocation.  When <methodname>SocketServerInvoker.stop()</methodname>
        is called, it calls the synchronized method <methodname>ServerThread.shutdown()</methodname>
        for each <classname>ServerThread</classname>, which insures that the server
        does not shut down until all currently invocations are complete.
        </para>
        
        <para>However, if it happens that an invocation gets hung up for some reason, the
        server would be prevented from shutting down.  For example, the 
        <classname>ServerInvocationHandler</classname> could have a bug, or an attempt
        to write to a disconnected network could get hung up.  As of Release 2.5.2, there
        is an option to shut down a <classname>SocketServerInvoker</classname> immediately
        without waiting for current invocations to complete.  This option can be enabled
        by setting the property "immediateShutdown" to "true".
        </para>

        <bridgehead><emphasis role="bold">Client</emphasis></bridgehead>

        <para>When the socket client invoker makes its first invocation, it will
        check to see if there is an available socket connection in its pool.
        Since is the first invocation, there will not be and will create a new
        socket connection and use it for making the invocation. Then when
        finished making invocation, will return the still active socket
        connection to the pool. As more client invocations are made, is possible
        for the number of socket connections to reach the maximum allowed (which
        is controlled by 'clientMaxPoolSize' property). At this point, when the
        next client invocation is made, it will wait up to some configured
        number of milliseconds, at which point it will throw an
        <classname>org.jboss.remoting.CannotConnectException</classname>. The
        number of milliseconds is given by the parameter
        <code>MicroSocketClientInvoker.CONNECTION_WAIT</code> (actual value
        "connectionWait"), with a default of 30000 milliseconds. Note that if
        more than one call retry is configured (see next paragraph), the
        <classname>CannotConnectException</classname> will be swallowed.</para>

        <para>Once the socket client invoker get an available socket connection
        from the pool, are not out of the woods yet. For example, a network
        problem could cause a <classname>java.net.SocketException</classname>.
        There is also a possibility that the socket connection, while
        still appearing to be valid, has "gone stale" while sitting in the pool.
        For example, a <classname>ServerThread</classname> on the other side of
        the connection could time out and close its socket. If the attempt to
        complete an invocation fails, then
        <classname>MicroSocketClientInvoker</classname> will make a number of
        attempts, according to the parameter "numberOfCallRetries", with a
        default value of 3. Once the configured number of retries has been
        exhausted, an
        <classname>org.jboss.remoting.InvocationFailureException</classname>
        will be thrown.</para>
        
      </section>
      
      <section>
         <title>Configuration</title>
         
        <para>The following configuration properties can be set at any time. If
        the <classname>SocketServerInvoker</classname> has already started, they
        will not take effect until it is stopped and restarted.</para>
  
        <para><emphasis role="bold">timeout</emphasis> - The socket timeout
        value passed to the Socket.setSoTimeout() method. The default on the
        server side is 60000 (one minute). If the timeout parameter is set, its
        value will also be passed to the client side (see below).</para>
  
        <para><emphasis role="bold">backlog</emphasis> - The preferred number of
        unaccepted incoming connections allowed at a given time. The actual
        number may be greater than the specified backlog. When the queue is
        full, further connection requests are rejected. Must be a positive value
        greater than 0. If the value passed if equal or less than 0, then the
        default value will be assumed. The default value is 200.</para>
  
        <para><emphasis role="bold">numAcceptThreads</emphasis> - The number of
        threads that exist for accepting client connections. The default is
        1.</para>
  
        <para><emphasis role="bold">maxPoolSize</emphasis> - The number of
        server threads for processing client. The default is 300.</para>
  
        <para><emphasis role="bold">serverSocketClass</emphasis> - specifies the
        fully qualified class name for the custom SocketWrapper implementation
        to use on the server.</para>
  
        <para><emphasis role="bold">socket.check_connection</emphasis> -
        indicates if the invoker should try to check the connection before
        re-using it by sending a single byte ping from the client to the server
        and then back from the server. This config needs to be set on both
        client and server to work. This if false by default.</para>
  
        <para><emphasis role="bold">idleTimeout</emphasis> - indicates the
        number of seconds a pooled server thread can be idle (meaning time since
        last invocations request processed) before it should be cleaned up and
        removed from the thread pool. The value for this property must be
        greater than zero in order to enable idle timeouts on pooled server
        threads (otherwise they will not be checked). Setting to value less than
        zero will disable idle timeout checks on pooled server threads, in the
        case was previously enabled. The default value for this property is
        -1.</para>
        
        <para><emphasis role="bold">evictabilityTimeout</emphasis> - indicates
        the number of milliseconds during which a server thread waiting for the
        next invocation will not be interruptible.</para>
        
        <para><emphasis role="bold">continueAfterTimeout</emphasis> - indicates
        what a server thread should do after experiencing a
        <classname>java.net.SocketTimeoutException</classname>. If set to
        "true", or if JBossSerialization is being used, the server thread will
        continue to wait for an invocation; otherwise, it will return itself to
        the thread pool.</para>
        
        <para><emphasis role="bold">immediateShutdown</emphasis> - indicates, when
        set to "true", that, when <methodname>Connector.stop()</methodname> is
        called and it calls <methodname>SocketServerInvoker.stop()</methodname>,
        all <classname>ServerThread</classname>s are shut down immediately,
        even if they are processing an invocation.</para>
        
        <bridgehead>Configurations affecting the Socket invoker
        client</bridgehead>
  
        <para>There are some configurations which will impact the socket invoker
        client. They can be set in the <classname>InvokerLocator</classname>, an
        MBean or bean XML configuration file, or can be passed in the
        configuration map when the <classname>Client</classname> is
        created.</para>
  
        <para><emphasis role="bold">enableTcpNoDelay</emphasis> - can be either
        true or false and will indicate if client socket should have TCP_NODELAY
        turned on or off. TCP_NODELAY is for a specific purpose; to disable the
        Nagle buffering algorithm. It should only be set for applications that
        send frequent small bursts of information without getting an immediate
        response; where timely delivery of data is required (the canonical
        example is mouse movements). The default is false.</para>
  
        <para><emphasis role="bold">timeout</emphasis> - The socket timeout
        value passed to the Socket.setSoTimeout() method. The default on the
        client side is 1800000 (or 30 minutes).</para>
  
        <para><emphasis role="bold">clientMaxPoolSize</emphasis> - the client
        side maximum number of active socket connections. This basically equates
        to the maximum number of concurrent client calls that can be made from
        the socket client invoker. The default is 50.</para>

        <para><emphasis role="bold">numberOfCallRetries</emphasis> - the number of
        times a failed invocation will be retried. For example, it is possible that the
        server side of a socket connection could time out, leaving the connection
        invalid.  In that case, the socket will be discarded and another, possibly
        new, socket will be used.  Note that after numberOfCallRetries - 2 attempts,
        the connection pool will be flushed on the assumption that all connections
        are invalid.  After numberOfCallRetries attempts, an
        <classname>InvocationFailureException</classname>, whose cause is the original
        exception, will be thrown.  The default value is 3.  See also the
        "generalizeSocketException" parameter, below</para>
               
        <para><emphasis role="bold">generalizeSocketException</emphasis> -
        If set to false, a failed invocation will be retried in the case of
        <classname>SocketException</classname>s.
        If set to true, a failed invocation will be retried in the case of
        <classname>SocketException</classname>s and also any <classname>IOException</classname>
        whose message matches the regular expression
        <code>^.*(?:connection.*reset|connection.*closed|broken.*pipe).*$</code>.
        See also the "numberOfCallRetries" parameter, above. The default value is
        false.</para>
  
        <para><emphasis role="bold">clientSocketClass</emphasis> - specifies the
        fully qualified class name for the custom SocketWrapper implementation
        to use on the client. Note, will need to make sure this is marked as a
        client parameter (using the 'isParam' attribute). Making this change
        will not affect the marshaller/unmarshaller that is used, which may also
        be a requirement.</para>
  
        <para><emphasis role="bold">socket.check_connection</emphasis> -
        indicates if the invoker should try to check the connection before
        re-using it by sending a single byte ping from the client to the server
        and then back from the server. This config needs to be set on both
        client and server to work. This if false by default.</para>
        
        <para><emphasis role="bold">useOnewayConnectionTimeout</emphasis> -
        indicates if, during a client side oneway invocation,
        <classname>MicroSocketClientInvoker</classname> should wait for a
        version byte from the server, which prevents the anomalous behavior
        described in JBREM-706 "In socket transport, prevent client side oneway
        invocations from artificially reducing concurrency". The default value
        is "true".</para>
        
        <para><emphasis role="bold">Note.</emphasis> As of Remoting version 2.4,
        the following socket parameters, in addition to SO_TIMEOUT and
        TCP_NODELAY, can be configured on the client client side: SO_KEEPALIVE,
        OOBINLINE, SO_RCVBUF, SO_REUSEADDR, SO_SNDBUF, SO_LINGER, and "traffic
        class". They are configured by the following parameter keys:</para>
        
        <para><emphasis role="bold">keepAlive</emphasis> - sets socket parameter
        SO_KEEPALIVE</para>
        
        <para><emphasis role="bold">oOBInline</emphasis> - sets socket parameter
        OOBINLINE</para>   
        
        <para><emphasis role="bold">receiveBufferSize</emphasis> - sets socket
        parameter SO_RCVBUF</para> 
        
        <para><emphasis role="bold">reuseAddress</emphasis> - sets socket
        parameter SO_REUSEADDR</para>
        
        <para><emphasis role="bold">sendBufferSize</emphasis> - sets socket
        parameter SO_SNDBUF</para>
        
        <para><emphasis role="bold">soLinger</emphasis> - sets socket parameter
        SO_LINGER</para>
  
        <para><emphasis role="bold">soLingerDuration</emphasis> - when socket
        parameter SO_LINGER is set to "true", sets linger duration</para>
        
        <para><emphasis role="bold">trafficClass</emphasis> - sets socket
        traffic class</para>
        
        <para>For more information about these parameters, see the
        <classname>java.net.Socket</classname> javadoc (<ulink
        url="http://java.sun.com/j2se/1.4.2/docs/api/java/net/Socket.html">
        http://java.sun.com/j2se/1.4.2/docs/api/java/net/Socket.html</ulink>) or
        a book about the TCP protocol.</para>
      </section>
                              
    </section>

    <section>
      <title>SSL Socket transport</title>

      <para>Supports all the configuration attributes as the Socket Invoker.
      The main difference is that the SSL Socket Invoker uses an
      <classname>SSLServerSocket</classname> by default, created by an
      <classname>SSLServerSocketFactory</classname>. See section <xref
      linkend="section-socket-factories" /> for more information.</para>
    </section>

    <section>
      <title>RMI transport</title>

      <para><emphasis role="bold">registryPort</emphasis> - the port on which
      to create the RMI registry. The default is 3455. This also needs to have
      the isParam attribute set to true.</para>

      <para><emphasis role="bold">Note.</emphasis> The RMI server invoker
      creates a socket factory and passes it to a client invoker along with
      the RMI stub, so the socket factory must be serializable. Therefore, if
      a socket factory is passed in to the server invoker by one of the
      methods discussed in section <xref
      linkend="section-socket-factories" />, then the user is responsible for
      supplying a serializable socket factory.</para>
      
      <para><emphasis role="bold">Note.</emphasis> Prior to Remoting version
      2.4, the RMI transport performed marshalling and unmarshalling only in the
      client to server direction. As of version 2.4, it will use a marshaller
      and unmarshaller in the server to client direction, as well. Moreover,
      marshalling and unmarshalling in the client to server direction has been
      made more efficient, which results in the transmission of a different
      sequence of bytes. In case a version 2.4 release of Remoting needs to
      communicate with an older version, it is possible to request the original
      marshalling behavior by setting the parameter
      <code>org.jboss.remoting.transport.rmi.RMIServerInvoker.RMI_ONEWAY_MARSHALLING</code>
      (actual value "rmiOnewayMarshalling") to "true".</para>
    </section>

    <section>
      <title>SSL RMI Invoker</title>

      <para>This is essentially identical to the RMI invoker, except that it
      creates SSL socket and server socket factories by default.</para>

      <para><emphasis role="bold">Note.</emphasis> The SSL RMI server invoker
      creates a socket factory and passes it to a client invoker along with
      the RMI stub, so the socket factory must be serializable. If the SSL RMI
      server invoker is allowed to create an
      <classname>SSLSocketFactory</classname> from SSL parameters, as
      discussed in section <xref linkend="section-socket-factories" />, it
      will take care to create a serializable socket factory. However, if a
      socket factory is passed in to the server invoker (also discussed in
      section <xref linkend="section-socket-factories" />), then the user is
      responsible for supplying a serializable socket factory. See <xref
      linkend="subsection-sslrmi" /> below for more information.</para>
    </section>

    <section id="section-http-invoker" xreflabel="HTTP Invoker">
      <title>HTTP transport</title>

      <para>The HTTP server invoker implementation is based on the Coyote
      HTTP/1.1 Connector Tomcat component, which is supplied by the JBossWeb
      implementation, in jbossweb.jar.</para>
      
      <para><emphasis role="bold">Note.</emphasis> Prior to release 2.5.0.GA,
      Remoting also was compatible with the Apache implementation of
      Tomcat, which is no longer the case.  Since JBossWeb requires jdk 1.5 or above, it follows that the HTTP transport in Remoting 2.5.0.GA and above has the same requirement.</para>
      
      <para>The coyote Connector supports GET, POST, HEAD, OPTIONS, and HEAD
      method types and keep-alive, and most any configuration allowed for Tomcat
      can be configured for the remoting HTTP server invoker. For more
      information on the configuration attributes available for the Tomcat
      connectors, please refer to <ulink
      url="http://tomcat.apache.org/tomcat-5.5-doc/config/http.html">http://tomcat.apache.org/tomcat-5.5-doc/config/http.html</ulink>.
      http://tomcat.apache.org/tomcat-5.5-doc/config/http.html <!--<link
      linkend="???">http://tomcat.apache.org/tomcat-5.5-doc/config/http.html</link>-->
      So for example, if wanted to set the maximum number of threads to be used
      to accept incoming http requests, would use the 'maxThreads' attribute.
      The only exception when should use remoting configuration over the Tomcat
      configuration is for attribute 'address' (use serverBindAddress instead)
      and attribute 'port' (use serverBindPort instead).</para>
      
      <para>Note: The http invoker no longer has the configuration attributes
      'maxNumThreadsHTTP' or 'HTTPThreadPool' as thread pooling is now handled
      within the Tomcat connectors, which does not expose external API for
      setting these.</para>
      
      <para>A feature introduced in Remoting version 2.4 is the ability to
      configure <classname>HTTPClientInvoker</classname> to make multiple
      attempts to complete an invocation. The feature is invoked by setting
      parameter <code>HTTPClientInvoker.NUMBER_OF_CALL_ATTEMPTS</code> (actual
      value "numberOfCallAttempts") to the desired integer. The parameter can be
      configured in the <classname>InvokerLocator</classname> or in the
      configuration map passed to the <classname>Client</classname>. The default
      value is 1.</para>
      
      <para>Since the remoting HTTP server invoker implementation is using
      Tomcat connectors, is possible to swap out the Tomcat protocol
      implementations being used. By default, the protocol being used is
      <code>org.apache.coyote.http11.Http11Protocol</code>. However, it is
      possible to switch to use the
      <code>org.apache.coyote.http11.Http11AprProtocol</code> protocol, which is
      based on the Apache Portable Runtime (see <ulink
      url="http://www.jboss.org/file-access/default/members/jbossweb/freezone/docs/2.1.0/apr.html">
      http://www.jboss.org/file-access/default/members/jbossweb/freezone/docs/2.1.0/apr.html</ulink>
      for more details). If want to use the APR implementation, simply put the
      tcnative-1.dll (or tcnative-1.so) on the system path so can be loaded. The
      JBossWeb native libraries, which include tcnative-1.dll/tcnative-1.so, may
      be downloaded from <ulink
      url="http://www.jboss.org/jbossweb/">http://www.jboss.org/jbossweb/</ulink>.</para>
      
      <bridgehead>Client request headers</bridgehead>

      <para>The HTTP Invoker allows for some of the properties to be passed as
      request headers from client caller. The following are possible http
      headers and what they mean:</para>

      <para><emphasis role="bold">sessionId</emphasis> - is the remoting
      session id to identify the client caller. If this is not passed, the
      HTTP server invoker will try to create a session id based on information
      that is passed. Note, this means if the sessionId is not passed as part
      of the header, there is no guarantee that the sessionId supplied to the
      invocation handler will always indicate the request from the same
      client.</para>

      <para><emphasis role="bold">subsystem</emphasis> - the subsystem to call
      upon (which invoker handler to call upon). If there is more than one
      handler per Connector, this will need to be set (otherwise will just use
      the only one available).</para>

      <para>These request headers are set automatically when using a remoting
      client, but if using another client to send request to the HTTP server
      invoker, may want to add these headers.</para>
      
      <bridgehead>Response headers</bridgehead>
    
      <para>If a request on the HTTP transport is made with the
      <classname>org.jboss.remoting.Client</classname> method</para>
      
      <programlisting>public Object invoke(Object param, Map metadata) throws Throwable</programlisting>
      
      <para>then
      <classname>org.jboss.remoting.transport.http.HTTPClientInvoker</classname>
      returns the HTTP response headers in a map in metadata, associated with
      the key
      <code>org.jboss.remoting.transport.http.HTTPMetadataConstants.RESPONSE_HEADERS</code>
      (actual value "ResponseHeaders"). For example, the response header "Date"
      can be retrieved as follows:</para>
      
      <programlisting>Object payload = ... ;
HashMap metadata = new HashMap();
client.invoke(payload, metadata);
Map responseHeaders = (Map) metadata.get(HTTPMetadataConstants.RESPONSE_HEADERS);
String date = (String) responseHeaders.get("Date");</programlisting>
      
      <bridgehead>CR/LF in HTTP transport</bridgehead>
    
      <para>By default, the HTTP transport uses
      <classname>org.jboss.remoting.marshal.http.HTTPMarshaller</classname> and
      <classname>org.jboss.remoting.marshal.http.HTTPUnMarshaller</classname> to
      marshal and unmarshal invocations and responses. Prior to Remoting version
      2.4, <classname>HTTPUnMarshaller</classname> stripped CR/LF characters. As
      of version 2.4, the default behavior remains the same, but it is possible
      to change the behavior, on the client and the server, by setting the
      parameter <code>HTTPUnMarshaller.PRESERVE_LINES</code> (actual value
      "preserveLines") to "true". </para>
      
    </section>
          
    <section>
      <title>HTTPS transport</title>

      <para>Supports all the configuration attributes as the HTTP Invoker,
      plus the following:</para>

      <para><emphasis role="bold">SSLImplementation</emphasis> - Sets the
      Tomcat SSLImplementation to use. This should always be
      <code>org.jboss.remoting.transport.coyote.ssl.RemotingSSLImplementation</code>.</para>

      <para>The main difference with the HTTP invoker is that the HTTPS
      Invoker uses an <classname>SSLServerSocket</classname> by default,
      created by an <classname>SSLServerSocketFactory</classname>. See section
      <xref linkend="section-socket-factories" /> for more information.</para>
    </section>

    <section>
      <title>HTTP(S) Client Invoker - proxy and basic authentication</title>

      <para>This section covers configuration specific to the HTTP Client
      Invoker only and is NOT related to HTTP(S) invoker configuration on the
      server side (via service xml).</para>

      <bridgehead>proxy</bridgehead>

      <para>There are a few ways in which to enable http proxy using the HTTP
      client invoker. The first is simply to add the following properties to
      the metadata Map passed on the Client's invoke() method:
      <code>http.proxyHost</code> and <code>http.proxyPort</code>.</para>

      <para>An example would be:</para>

      <programlisting>Map metadata = new HashMap();
...

// proxy info
metadata.put("http.proxyHost", "ginger");
metadata.put("http.proxyPort", "80");

...

response = client.invoke(payload, metadata);</programlisting>

      <para>The http.proxyPort property is not required and if not present,
      will use default of 80. Note: setting the proxy config in this way can
      ONLY be done if using JDK 1.5 or higher.</para>

      <para>The other way to enable use of an http proxy server from the HTTP
      client invoker is to set the following system properties (either via
      <code>System.setProperty()</code> method call or via JVM arguments):
      <code>http.proxyHost</code>, <code>http.proxyPort</code>, and
      <code>proxySet</code>.</para>

      <para>An example would be setting the following JVM arguments:</para>

      <programlisting>-Dhttp.proxyHost=ginger -Dhttp.proxyPort=80 -DproxySet=true</programlisting>

      <para>Note: when testing with Apache 2.0.48 (mod_proxy and
      mod_proxy_http), all of the properties above were required.</para>

      <para>Setting the system properties can be used for JDK 1.4 and higher.
      However, will not be able to specify proxy server per remoting client if
      use system properties..</para>

      <bridgehead>Basic authentication - direct and via proxy</bridgehead>

      <para>The HTTP client invoker also has support for BASIC authentication
      for both proxied and non-proxied invocations. For proxied invocations,
      the following properties need to be set:
      <code>http.proxy.username</code> and
      <code>http.proxy.password</code>.</para>

      <para>For non-proxied invocations, the following properties need to be
      set: <code>http.basic.username</code> and
      <code>http.basic.password</code>.</para>

      <para>For setting either proxied or non-proxied properties, can be done
      via the metadata map or system properties (see setting proxy properties
      above for how to). However, for authentication properties, values set in
      the metadata Map will take precedence over those set within the system
      properties.</para>

      <para>Note: Only the proxy authentication has been tested using Apache
      2.0.48; non-proxied authentication has not.</para>

      <para>Since there are many different ways to do proxies and
      authentication in this great world of web, not all possible
      configurations have been tested (or even supported). If you find a
      particular problem or see that a particular implementation is not
      supported, please enter an issue in Jira (<ulink
      url="http://jira.jboss.com">http://jira.jboss.com</ulink>) under the
      JBossRemoting project, as this is where bugs and feature requests
      belong. If after reading the documentation have unanswered questions
      about how to use these features, please post them to the remoting forum
      (<ulink
      url="http://www.jboss.org/index.html?module=bb&amp;op=viewforum&amp;f=222">
      http://www.jboss.org/index.html?module=bb&amp;op=viewforum&amp;f=222
      </ulink>).</para>

      <bridgehead>Host name verification</bridgehead>

      <para>During the SSL handshake when making client calls using https
      transport, if the URL's hostname and the server's identification
      hostname mismatch, a javax.net.ssl.HostnameVerifier implementation will
      be called to determine if this connection should be allowed. The default
      implementation will not allow this, but it is possible to override the default
      behavior</para>
      
      <para>One option is to use the key <code>HTTPSClientInvoker.HOSTNAME_VERIFIER</code>
      (actual value "hostnameVerifier") to supply the name of a class that implements
      the <classname>javax.net.ssl.HostnameVerifier</classname> interface, passing it
      either in the metadata map supplied with an invocation or in the configuration map
      supplied when the <classname>HTTPSClientInvoker</classname> was created.  If the key
      appears in both maps, the value in the metadata map takes precedence.
      </para>
      
      <para>In the absence of an explicitly declared <classname>HostnameVerifier</classname>,
      another way to configure the hostname verification behavior is to declare that all host
      names are acceptable, which can be accomplished by setting the
      <code>HTTPSClientInvoker.IGNORE_HTTPS_HOST</code> property (actual value
      "org.jboss.security.ignoreHttpsHost") to true.  In order of  increasing precedence,
      the property may be set (1) as a system property, (2) in the configuration map supplied
      when the <classname>HTTPSClientInvoker</classname> was created, or in the metadata map
      supplied with an invocation.</para>
      
      <para>Finally, in the absence of both an explicitly declared
      <classname>HostnameVerifier</classname> and an explicit directive to ignore host
      names, an <classname>HTTPSClientInvoker</classname> will check to see if its
      <classname>SocketFactory</classname> is an instance of
      <classname>org.jboss.remoting.security.CustomSSLSocketFactory</classname> and, if so,
      if authentication has been turned off.  If that is the case, host names will be ignored.
      See Section <xref linkend="section-socket-factories" /> for more information about
      <classname>SocketFactory</classname> configuration.
      
      </para>

    </section>

    <section>
      <title>Servlet transport</title>

      <para>The servlet invoker is a server invoker implementation that uses a
      servlet running within a web container to accept initial client
      invocation requests. The servlet request is then passed on to the
      servlet invoker for processing.</para>

      <para>The deployment for this particular server invoker is a little
      different than the other server invokers since a web deployment is also
      required. To start, the servlet invoker will need to be configured and
      deployed. This can be done by adding the Connector MBean service to an
      existing service xml or creating a new one. The following is an example
      of how to declare a Connector that uses the servlet invoker:</para>

      <programlisting>&lt;mbean code="org.jboss.remoting.transport.Connector"
       name="jboss.remoting:service=Connector,transport=Servlet"
       display-name="Servlet transport Connector"&gt;

   &lt;attribute name="InvokerLocator"&gt;
      servlet://localhost:8080/servlet-invoker/ServerInvokerServlet
   &lt;/attribute&gt;

   &lt;attribute name="Configuration"&gt;
      &lt;config&gt;
         &lt;handlers&gt;
            &lt;handler subsystem="test"&gt;
               org.jboss.test.remoting.transport.web.WebInvocationHandler
            &lt;/handler&gt;
         &lt;/handlers&gt;
      &lt;/config&gt;
   &lt;/attribute&gt;
&lt;/mbean&gt;</programlisting>

      <para>An important point of configuration to note is that the value for
      the InvokerLocator attribute is the exact url used to access the servlet
      for the servlet invoker (more on how to define this below), with the
      exception of the protocol being servlet instead of http. This is
      important if using automatic discovery, as this is the locator url that
      will be discovered and used by clients to connect to this server
      invoker.</para>

      <para>The next step is to configure and deploy the servlet that fronts
      the servlet invoker. The pre-built deployment file for this servlet is
      the servlet-invoker.war file (which can be found in lib directory of the
      release distribution or under the output/lib/ directory if doing a
      source build). By default, it is actually an exploded war, so the
      servlet-invoker.war is actually a directory so that can be more easily
      configured (feel free to zip up into an actual war file if prefer). In
      the WEB-INF directory is located the web.xml file. This is a standard
      web configuration file and should look like:</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE web-app PUBLIC
   "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
   "http://java.sun.com/dtd/web-app_2_3.dtd"&gt;

&lt;web-app&gt;
   &lt;servlet&gt;
      &lt;servlet-name&gt;ServerInvokerServlet&lt;/servlet-name&gt;
      &lt;description&gt;
         The ServerInvokerServlet receives requests via HTTP protocol from 
         within a web container and passes it onto the ServletServerInvoker 
         for processing.
      &lt;/description&gt;
      &lt;servlet-class&gt;
         org.jboss.remoting.transport.servlet.web.ServerInvokerServlet
      &lt;/servlet-class&gt;
      &lt;init-param&gt;
         &lt;param-name&gt;invokerName&lt;/param-name&gt;
         &lt;param-value&gt;jboss.remoting:service=invoker,transport=servlet&lt;/param-value&gt;
         &lt;description&gt;The servlet server invoker&lt;/description&gt;
         &lt;!--
         &lt;param-name&gt;locatorUrl&lt;/param-name&gt;
         &lt;param-value&gt;
            servlet://localhost:8080/servlet-invoker/ServerInvokerServlet
         &lt;/param-value&gt;
         &lt;description&gt;The servlet server invoker locator url&lt;/description&gt;
         --&gt;
      &lt;/init-param&gt;
      &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
   &lt;/servlet&gt;
   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;ServerInvokerServlet&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/ServerInvokerServlet/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</programlisting>

      <para>There are two ways in which the servlet can obtain a reference to
      the servlet server invoker it needs to pass its request onto. The first
      is by using the param 'invokerName', as is shown above. The value for
      this should be the JMX ObjectName for the servlet server invoker that
      was deployed as a service mbean (see service xml above). The other way
      is to provide a param 'locatorUrl' with a value that matches the locator
      url of the servlet server invoker to use. In this case, will use the
      InvokerRegistry to find the server invoker instead of using JMX, which
      is useful if not deploying server invoker as a mbean service or if want
      to run in web container other than the JBoss application server. Note,
      one or the other param is required. If both are provided, the
      'locatorUrl' param take precedence.</para>

      <para>This file can be changed to meet any web requirements you might
      have, such as adding security (see sslservlet) or changing the actual
      url context that the servlet maps to. If the url that the servlet maps
      to is changed, will need to change the value for the InvokerLocator in
      the Connector configuration mentioned above.</para>
      
      <para><emphasis role="bold">Note.</emphasis> Prior to Remoting version
      2.4,
      <classname>org.jboss.remoting.transport.servlet.ServletServerInvoker</classname>
      generated a single MBean ObjectName for representing
      <classname>ServletServerInvoker</classname>s as MBeans, which meant that
      an MBeanServer could be aware of only a single
      <classname>ServletServerInvoker</classname> MBean. As of version 2.4, that
      restriction has been eliminated.</para>
      
      <para><emphasis role="bold">Note.</emphasis> Prior to Remoting version
      2.4, when
      <classname>org.jboss.remoting.transport.servlet.web.ServerInvokerServlet</classname>
      retrieved an MBeanServer, it looked only for an MBeanServer whose default
      domain was "jboss". As of version 2.4, the default domain can be
      configured by adding an "mbeanServer" init-param element to the web.xml
      file. If the "mbeanServer" value is set to "*platform*" and jdk 1.5 or
      greater is in use, <classname>ServerInvokerServlet</classname> will
      retrieve the platform MBeanServer by calling
      <methodname>java.lang.management.ManagementFactory.getPlatformMBeanServer()</methodname>.
      In the absence of a configured default domain,
      <classname>ServerInvokerServlet</classname> will still use "jboss" as the
      default domain.</para>
      
      <section>
         <title>Configuration</title>
         
        <para><emphasis role="bold">unwrapSingletonArrays</emphasis> - If the map
        returned by <methodname>javax.servlet.http.HttpServletRequest.getParameterMap()</methodname>
        maps a String key to an array of length one, the value in the array will be extracted
        and associated with the key.</para>
      </section>
    </section>

    <section>
      <title>SSL Servlet transport</title>

      <para>The SSL Servlet Invoker is exactly the same as its parent, Servlet
      Invoker, with the exception that it uses the protocol of 'sslservlet'.
      On the server side it is deployed exactly the same as a servlet invoker
      would be but requires setting up ssl within the web container (i.e.
      enabling the ssl connector within Tomcat's server.xml). This will
      usually require specifing a different port as well.</para>

      <para>An example of the mbean service xml for deploying the ssl servlet
      server invoker would be:</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;server&gt;
   &lt;mbean code="org.jboss.remoting.transport.Connector"
          name="jboss.remoting:service=Connector,transport=SSLServlet"
          display-name="SSL Servlet transport Connector"&gt;

      &lt;attribute name="InvokerLocator"&gt;
         sslservlet://localhost:8443/servlet-invoker/ServerInvokerServlet
      &lt;/attribute&gt;
      &lt;attribute name="Configuration"&gt;
         &lt;config&gt;
            &lt;handlers&gt;
               &lt;handler subsystem="test"&gt;
                  org.jboss.test.remoting.transport.web.WebInvocationHandler
               &lt;/handler&gt;
            &lt;/handlers&gt;
         &lt;/config&gt;
      &lt;/attribute&gt;
   &lt;/mbean&gt;
&lt;/server&gt;</programlisting>

      <para>An example of servlet-invoker.war/WEB-INF/web.xml for the ssl
      server invoker servlet would be:</para>

      <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE web-app PUBLIC
    "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
    "http://java.sun.com/dtd/web-app_2_3.dtd"&gt;

&lt;web-app&gt;
   &lt;servlet&gt;
      &lt;servlet-name&gt;ServerInvokerServlet&lt;/servlet-name&gt;
      &lt;description&gt;
         The ServerInvokerServlet receives requests via HTTP protocol from 
         within a web container and passes it onto the ServletServerInvoker
         for processing.
      &lt;/description&gt;
      &lt;servlet-class&gt;
         org.jboss.remoting.transport.servlet.web.ServerInvokerServlet
      &lt;/servlet-class&gt;
      &lt;init-param&gt;
         &lt;param-name&gt;locatorUrl&lt;/param-name&gt;
         &lt;param-value&gt;
            sslservlet://localhost:8443/servlet-invoker/ServerInvokerServlet
         &lt;/param-value&gt;
         &lt;description&gt;The servlet server invoker locator url&lt;/description&gt;
      &lt;/init-param&gt;
      &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
   &lt;/servlet&gt;
   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;ServerInvokerServlet&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/ServerInvokerServlet/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</programlisting>
    </section>

    <section>
      <title>Exception handling for web based clients</title>

      <para>Web based clients, meaning remoting clients that call on web based
      remoting servers (i.e. http, https, servlet, and sslservlet) have
      special needs when it comes to handling exceptions that come from the
      servers they are calling on. The main reason for this is that depending
      on what type of server they are calling on, they might receive the error
      in different formats.</para>

      <para>By default, web based clients will throw an exception when the
      response code from the server is greater than 400. The exact exception
      type thrown will depend on the type of web server the client is
      interacting with. If it is a JBoss Remoting server (http or https server
      invoker), the exception thrown will be the one originally generated on the
      server side. If the server is not a JBoss Remoting server (e.g. JBossAS,
      Tomcat, Apache Web Server, etc.), the exception thrown will be
      <code>org.jboss.test.remoting.transport.http.WebServerError</code>. The
      WebServerError's message will be the error html returned by the web
      server. Throwing an exception may be turned off with the parameter
      <code>HTTPMetadataConstants.NO_THROW_ON_ERROR</code> (actual text value
      "NoThrowOnError") set to "true". This parameter may be passed in the
      <classname>InvokerLocator</classname> or configuration map when the
      <classname>org.jboss.remoting.Client</classname> is created, or it may be
      included in the metadata map passed to</para>
      
      <programlisting>public Object invoke(Object param, Map metadata) throws Throwable;</programlisting>
      .
      <para>This will cause the http client invoker to not throw an exception,
      but instead return the data from the web server error stream. In the case
      that the data returned from this error stream is of type java.lang.String
      (i.e. is error html), it will be wrapped in a WebServerError and returned
      as this type. The raw data from the web server can the be retrieved by
      getting the WebServerError's message.</para>
      
      <para><emphasis role="bold">Note.</emphasis> Prior to Remoting version
      2.4, the servlet transport returned a simple error message in the event of
      an error on the server side. As of version 2.4, the discussion about
      exception handling applies to the servlet and sslservlet transports as
      well. The original behavior of returning an error message can be requested
      by configuring the server with the parameter
      <code>org.jboss.remoting.transport.http.HTTPMetadataConstants.DONT_RETURN_EXCEPTION</code>
      (actual value "dont-return-exception") set to "true".</para>
      
    </section>                                                                   

    <section id="section-multiplex-invoker" xreflabel="Multiplex Invoker">
      <title>Multiplex transport</title>

      <para>As of Remoting version 2.4, the multiplex transport is deprecated
      and will no longer be supported.</para>
    </section>

    <section>
      <title>SSL Multiplex transport</title>

      <para>As of Remoting version 2.4, the sslmultiplex transport is deprecated
      and will no longer be supported.</para>
    </section>
    
    <section>
      <title>Bisocket transport</title>
      
      <para>
        The <emphasis role="bold">bisocket transport</emphasis>, like the
        multiplex transport, is a bidirectional transport that can function
        in the presence of restrictions that would prevent a unidirectional
        transport like socket or http from creating a server to client push callback
        connection.  (See Section <xref linkend="section-callbacks"/> for more
        information about callbacks and bidirectional and unidirectional
        transports.)  For example, security restrictions could prevent the
        application from opening a <classname>ServerSocket</classname> on the
        client, or firewall restrictions could prevent the server from contacting a
        <classname>ServerSocket</classname> even if it were possible to create
        one.
      </para>
      
      <section>
        <title>Overview</title>
        <para>
          The bisocket client and server invokers inherit most of their
          functionality from the socket invokers, with the principal exception of
          overriding a method in the client invoker called
          <methodname>createSocket()</methodname>.  If
          the client invoker is on the client side, then
          <methodname>createSocket()</methodname> simply calls the super
          implementation.  The heart of the bisocket transport is in handling the
          case of creating a connection from a callback client invoker on the
          server side to a callback server invoker on the client side, which is
          mandated to occur without the use of a
          <classname>ServerSocket</classname> on the client side.  Whenever the
          bisocket transport is informed by an application of its intention to use
          push callbacks, the client side creates a secondary "control"
          connection, and subsequently, whenever the callback client invoker needs
          to create a connection to the callback server, it sends a request over
          the control connection asking the client side to establish the
          connection.  The server side of the transport maintains a secondary
          <classname>ServerSocket</classname> that accepts connection requests from
          the client side, and whenever a socket is created it is passed to whichever
          callback client invoker requested it. The client invoker, which 
          inherits the socket transport's connection pool management facility, adds
          the new socket to its connection pool.
        </para>
        
        <para>
          Note that if the control
          connection were to fail, no new connections could be created for the
          callback client invoker, and eventually callback transmission could come
          to a halt.  The client and server invokers work together, therefore, to
          maintain a heartbeat on the control connection and to
          recreate the control connection automatically should it fail.  In
          particular, the server side sends out ping messages on the control
          connection, and the client side needs to receive a ping message within
          some configured window in order to consider the connection to be
          functional.
        </para>
        
        <para>
          In addition to the configuration options inherited from the socket
          transport, the bisocket transport may be configured with the following
          parameters, which are defined as constants in the
          <classname>org.jboss.remoting.transport.bisocket.Bisocket</classname>
          class.  A parameter can be configured on the server side by appending
          it to the <classname>InvokerLocator</classname> or by adding it to the
          configuration map passed to the <classname>Connector</classname>'s
          constructor.  On the client side, where all parameters are used by the
          callback server invoker, there are several options for setting
          parameter values. If the callback <classname>Connector</classname>
          is created explicitly, then a parameter can be configured
          by appending it to the callback <classname>Connector</classname>'s
          <classname>InvokerLocator</classname> or
          by adding it to the configuration map passed to the callback 
          <classname>Connector</classname>'s constructor.  If the callback 
          <classname>Connector</classname> is created 
          implicitly by the <methodname>Client.addListener()</methodname> method,
          then its configuration map is the union of the
          <classname>Client</classname>'s configuration map and the
          <code>metadata</code> map passed as a parameter to
          <methodname>Client.addListener()</methodname>.
        </para>
        
        
        <para>
          <emphasis role="bold">IS_CALLBACK_SERVER</emphasis> (actual value is
          "isCallbackServer"): when a bisocket server invoker receives this
          parameter with a value of true, it avoids the creation of a
          <classname>ServerSocket</classname>. Therefore, IS_CALLBACK_SERVER
          should be used on the client side for the creation of a callback
          server. The default value is false.
        </para>
            
        <para>
          <emphasis role="bold">PING_FREQUENCY</emphasis> (actual
          value is "pingFrequency"): The server side uses this value
          to determine the interval, in milliseconds, between pings that it will
          send on the control connection.  The client side uses this value to
          calculate the window in which it must receive pings on the control
          connection.  In particular, the window is ping frequency * ping window factor.
          See also the definition of PING_WINDOW_FACTOR. The default value is 5000.
        </para>
        
        <para>
          <emphasis role="bold">PING_WINDOW_FACTOR</emphasis> (actual
          value is "pingWindowFactor"): The client side uses this value to
          calculate the window in which it must receive pings on the control
          connection.  In particular, the window is ping frequency * ping window factor.
          See also the definition of PING_FREQUENCY. The default value is 2.
        </para>
        
        <para>
          <emphasis role="bold">MAX_RETRIES </emphasis> (actual value is
          "maxRetries"): This parameter is relevant only on the client side,
          where the <classname>BisocketClientInvoker</classname> uses it
          to govern the number of attempts it should make to get the address and
          port of the secondary <classname>ServerSocket</classname>, and the
          <classname>BisocketServerInvoker</classname> uses it to govern the
          number of attempts it should make to create both ordinary and control
          sockets. The default value is 10. </para>
          
        <para>
          <emphasis role="bold">MAX_CONTROL_CONNECTION_RESTARTS</emphasis>
          (actual value is "maxControlConnectionRestarts"): The client side uses
          this value to limit the number of times it will request a new control
          connection after a ping timeout. The default value is 10.
        </para>
        
        <para>
          <emphasis role="bold">SECONDARY_BIND_PORT</emphasis> (actual value is
          "secondaryBindPort"): The server side uses this parameter to determine
          the bind port for the secondary
          <classname>ServerSocket</classname>.</para>
          
        <para>
          <emphasis role="bold">SECONDARY_BIND_PORTS</emphasis> (actual value is
          "secondaryBindPorts"): The server side uses this parameter to
          determine the bind ports for the secondary
          <classname>ServerSocket</classname>s in a multihome server.</para>
          
        <para>
          <emphasis role="bold">SECONDARY_CONNECT_PORT</emphasis> (actual value
          is "secondaryConnectPort"): The server side uses this parameter to
          determine the connect port used by the client side to connect to the
          secondary <classname>ServerSocket</classname>.</para>
          
        <para>
          <emphasis role="bold">SECONDARY_CONNECT_PORTS</emphasis> (actual value
          is "secondaryConnectPorts"): The server side uses this parameter to
          determine the connect ports used by the client side to connect to the
          secondary <classname>ServerSocket</classname>s in a multihome
          server.</para>
          
      </section>
      
      <section>
        <title>Details</title>
        
        <para>
          Using the bisocket transport certainly does not require understanding
          its implementation details, but some further information is presented
          in this section for those who might be interested.
        </para>
        
        <para>
          In the following discussion, the client side client invoker and the
          server side server invoker will be referred to simply as "client
          invoker" and "server invoker." The callback client invoker and
          callback server invoker will be explicitly identified as such.
        </para>
        
        <para>
          The following sequence of events occurs in the course of creating a
          control connection. For simplicity it is assumed that the
          <classname>Client</classname> and <classname>Connector</classname>
          have already been created, and that the callback server is created
          implicitly by the <classname>Client</classname>.   These events are
          illustrated in Figure 5.1.
        </para>

        <orderedlist>
          <listitem>
            The application calls <methodname>Client.addListener()</methodname>.
          </listitem>
          
          <listitem>
            The <classname>Client</classname> creates a callback
            <classname>Connector</classname> and the callback server invoker
            registers itself in a static map.
          </listitem>
          
          <listitem>
            The <classname>Client</classname> sends an "addListener" message
            to the server invoker by way of the client invoker.
          </listitem>
          
          <listitem>
            The client invoker intercepts the "addListener" message, which tells
            it that a callback server is being created.
            It retrieves the callback server invoker from the static map and
            tells it to create a control connection for the callback
            connection that is being constructed.
          </listitem>
          
          <listitem>
            The callback server invoker sends an internal message to the server
            invoker requesting the address and port of the secondary
            <classname>ServerSocket</classname>
          </listitem>
          
          <listitem>
            The callback server invoker connects to the secondary
            <classname>ServerSocket</classname> to create a
            <classname>Socket</classname> for the control connection. If it has
            not already done so, the callback server invoker creates a
            <classname>TimerTask</classname> which will monitor the state of all
            of its control connections. (Note that if the callback
            <classname>Connector</classname> is created explicitly, it could
            have multiple <classname>InvokerCallbackHandler</classname>s
            registered with it.)
          </listitem>
          
          <listitem>
            On the server side, the <classname>Socket</classname> just created
            by the secondary <classname>ServerSocket</classname> is stored in a
            static map, awaiting the creation of the callback client invoker.
          </listitem>
          
          <listitem>
            The client invoker transmits the "addListener" message to the
            server invoker.
          </listitem>
          
          <listitem>
            The server invoker creates a callback client invoker.
          </listitem>
          
          <listitem>
            The callback client invoker retrieves the waiting socket and uses it
            for the control connection. 
          </listitem>
          
          <listitem>
            The callback client invoker begins pinging on the control connection.
          </listitem>
        </orderedlist>
        
        <figure>
          <title>Creating a control connection.</title>
          <graphic fileref="images/bisocket1.png"
            width="765pt" depth="495"
            contentwidth="765pt" contentdepth="445"
            format="png" align="center"
          />
        </figure>

        <para>
          The following sequence of events occurs in the course of creating a
          connection for the callback client invoker to use for sending
          callbacks.  It is illustrated in Figure 5.2.
        </para>
        
        <orderedlist>
          <listitem>
            The <classname>ServerInvocationHandler</classname> calls
            <methodname>InvokerCallbackHandler.handleCallback()</methodname>.
          </listitem>
          
          <listitem>
            The <classname>InvocationCallbackHandler</classname> calls
            <methodname>invoke()</methodname> on the callback
            <classname>Client</classname>.
          </listitem>
          
          <listitem>
            The <classname>Client</classname> calls
            <methodname>invoke()</methodname> on the callback client invoker.
          </listitem>
          
          <listitem>
            If there are no connections in its connection pool, the callback
            client invoker sends a message on the control connection asking the
            callback server invoker to connect to the server side secondary
            <classname>ServerSocket</classname>. It then waits for the
            <classname>Socket</classname> to appear in a static map.
          </listitem>
          
          <listitem>
            The callback server invoker receives the request and calls upon
            either a <classname>Socket</classname> constructor or a
            <classname>SocketFactory</classname> to create a new
            <classname>Socket</classname>. It passes the new
            <classname>Socket</classname> to a worker thread to process
            subsequent callback invocations.
          </listitem>
          
          <listitem>
            The secondary <classname>ServerSocket</classname> creates a new
            <classname>Socket</classname>, which is placed in a static map.
          </listitem>
         
          <listitem>
            The callback client invoker retrieves the new
            <classname>Socket</classname>
          </listitem>
          
          <listitem>
            The callback client uses the new <classname>Socket</classname> to
            transmit a callback, and adds the new connection to its connection
            pool for later use.
          </listitem>
        </orderedlist>
        
        <figure>
          <title>Creating a callback connection.</title>
          <graphic fileref="images/bisocket2.png"
            width="765pt" depth="495"
            contentwidth="765pt" contentdepth="445"
            format="png" align="center"
          />
        </figure>
        
        <para>
          The following sequence of events occurs when a control connection
          fails.  It is illustrated in Figure 5.3.
        </para>
        
        <orderedlist>
          <listitem>
            The callback server invoker notices that a ping has not been
            received during the control connection's current window.
          </listitem>
          
          <listitem>
            The callback server invoker reacquires the host and port of the
            secondary <classname>ServerSocket</classname>, just in case it has
            changed.
          </listitem>
          
          <listitem>
            The callback server invoker calls on a <classname>Socket</classname>
            constructor or <classname>SocketFactory</classname> to create a new
            <classname>Socket</classname>.
          </listitem>
          
          <listitem>
            The callback server invoker sends an internal message on the new
            connection directing the server to replace the current control
            connection with the new connection.
          </listitem>
          
          <listitem>
            After the secondary <classname>ServerSocket</classname> creates a
            new <classname>Socket</classname>, the <classname>Socket</classname>
            is passed directly to the client invoker in a method that replaces
            the old control connection with a new one.
          </listitem>
        </orderedlist>
        
        <figure>
          <title>Replacing a failed control connection.</title>
          <graphic fileref="images/bisocket3.png"
            width="765pt" depth="495"
            contentwidth="765pt" contentdepth="445"
            format="png" align="center"
          />
        </figure>
        
      </section>
    </section>
          
    <section>
      <title>SSL Bisocket transport</title>
      
      <para>
        The SSL bisocket transport has the same relation to the bisocket
        transport as the SSL socket transport has to the socket transport.
        That is, it uses an <classname>SSLServerSocket</classname> and creates
        <classname>SSLSocket</classname>s by default.  See Section <xref 
        linkend="section-socket-factories"/> for more information.
      </para>
      
      <para>
        SSL bisocket transport supports all the configuration attributes
        supported by the bisocket transport.
      </para>
    </section>
      
  </section>

  <section>
    <title>Marshalling</title>

    <para>Marshalling of data can range from extremely simple to somewhat
    complex, depending on how much customization is needed. The following
    explains how marshallers/unmarshallers can be configured. Note that this
    applies for all the different transports, but will use the socket
    transport for examples.</para>

    <para>The easiest way to configure marshalling is to specify nothing at
    all. This will prompt the remoting invokers to use their default
    marshaller/unmarshallers. For example, the socket invoker will use the
    SerializableMarshaller/SerializableUnMarshaller and the http invoker will
    use the HTTPMarshaller/HTTPUnMarshaller, on both the client and server
    side.</para>

    <para>The next easiest way is to specify the data type of the
    marshaller/unmarshaller as a parameter to the locator url. This can be
    done by simply adding the key word 'datatype' to the url, such as:</para>

    <programlisting>socket://myhost:5400/?datatype=serializable</programlisting>

    <para>This can be done for types that are statically bound within the
    <code>MarshalFactory</code>, serializable and http, without requiring any
    extra coding, since they will be available to any user of remoting.
    However, is more likely this will be used for custom marshallers (since
    could just use the default data type from the invokers if using the
    statically defined types). If using custom marshaller/unmarshaller, will
    need to make sure both are added programmatically to the
    <code>MarshalFactory</code> during runtime (on both the client and server
    side). This can be done by the following method call within the
    MarshalFactory:</para>

    <programlisting>public static void addMarshaller(
        String dataType, Marshaller marshaller, UnMarshaller unMarshaller)</programlisting>

    <para>The dataType passed can be any String value desired. For example,
    could add custom InvocationMarshaller and InvocationUnMarshaller with the
    data type of 'invocation'. An example using this data type would then
    be:</para>

    <programlisting>socket://myhost:5400/?datatype=invocation</programlisting>

    <para>One of the problems with using a data type for a custom
    Marshaller/UnMarshaller is having to explicitly code the addition of these
    within the MarshalFactory on both the client and the server. So another
    approach that is a little more flexible is to specify the fully qualified
    class name for both the Marshaller and UnMarshaller on the locator url.
    For example:</para>

    <programlisting>socket://myhost:5400/?datatype=invocation&amp;
            marshaller=org.jboss.invocation.unified.marshall.InvocationMarshaller&amp;
            unmarshaller=org.jboss.invocation.unified.marshall.InvocationUnMarshaller
         </programlisting>

    <para>This will prompt remoting to try to load and instantiate the
    Marshaller and UnMarshaller classes. If both are found and loaded, they
    will automatically be added to the MarshalFactory by data type, so will
    remain in memory. Now the only requirement is that the custom Marshaller
    and UnMarshaller classes be available on both the client and server's
    classpath.</para>

    <para>Another requirement of the actual Marshaller and UnMarshaller
    classes is that they have a void constructor. Otherwise loading of these
    will fail.</para>

    <para>This configuration can also be applied using the service xml. If
    using declaration of invoker using the InvokerLocator attribute, can
    simply add the datatype, marshaller, and unmarshaller parameters to the
    defined InvokerLocator attribute value. For example:</para>

    <programlisting>&lt;attribute name="InvokerLocator"&gt;
   &lt;![CDATA[socket://${jboss.bind.address}:8084/?datatype=invocation&amp;
      marshaller=org.jboss.invocation.unified.marshall.InvocationMarshaller&amp;
      unmarshaller=org.jboss.invocation.unified.marshall.InvocationUnMarshaller]]&gt;
&lt;/attribute&gt;</programlisting>

    <para>If were using config element to declare the invoker, will need to
    add an attribute for each and include the isParam attribute set to true.
    For example:</para>

    <programlisting>&lt;invoker transport="socket"&gt;
   &lt;attribute name="dataType" isParam="true"&gt;invocation&lt;/attribute&gt;
   &lt;attribute name="marshaller" isParam="true"&gt;
      org.jboss.invocation.unified.marshall.InvocationMarshaller
   &lt;/attribute&gt;
   &lt;attribute name="unmarshaller" isParam="true"&gt;
      org.jboss.invocation.unified.marshall.InvocationUnMarshaller
   &lt;/attribute&gt;
&lt;/invoker&gt;</programlisting>

    <para>This configuration is fine if the classes are present within the
    client's classpath. If they are not, can provide configuration for
    allowing clients to dynamically load the classes from the server. To do
    this, can use the parameter 'loaderport' with the value of the port you
    would like your marshal loader to run on. For example:</para>

    <programlisting>&lt;invoker transport="socket"&gt;
   &lt;attribute name="dataType" isParam="true"&gt;invocation&lt;/attribute&gt;
   &lt;attribute name="marshaller" isParam="true"&gt;
      org.jboss.invocation.unified.marshall.InvocationMarshaller
   &lt;/attribute&gt;
   &lt;attribute name="unmarshaller" isParam="true"&gt;
      org.jboss.invocation.unified.marshall.InvocationUnMarshaller
   &lt;/attribute&gt;
   &lt;attribute name="loaderport" isParam="true"&gt;5401&lt;/attribute&gt;
&lt;/invoker&gt;</programlisting>

    <para>When this parameter is supplied, the Connector will recognize this
    at startup and create a marshal loader connector automatically, which will
    run on the port specified. The locator url will be exactly the same as the
    original invoker locator, except will be using the socket transport
    protocol and will have all marshalling parameters removed (except the
    dataType). When the remoting client can not load the
    marshaller/unmarshaller for the specified data type, it will try to load
    them from the marshal loader service running on the loader port, including
    any classes they depend on. This will happen automatically and no coding
    is required (only the ability for the client to access the server on the
    specified loader port, so must provide access if running through
    firewall).</para>
    
    <para><emphasis role="bold">Note.</emphasis> Prior to release 2.5.2, only the
    parameters in the <classname>InvokerLocator</classname> were used to configure
    marshallers and unmarshallers.  As of release 2.5.2 the parameters in the
    configuration map passed to an <classname>org.jboss.remoting.Client</classname>
    or <classname>org.jboss.remoting.transport.Connector</classname> will also
    be used if the parameter
    <code>org.jboss.remoting.Remoting.PASS_CONFIG_MAP_TO_MARSHAL_FACTORY</code>
    (actual value "passConfigMapToMarshalFactory") is set to "true".</para>
    
    <bridgehead>Http marshalling</bridgehead>
    <para>By default, the http, https, servlet, and sslservlet transports use 
    <classname>org.jboss.remoting.marshal.http.HTTPMarshaller</classname> and
    <classname>org.jboss.remoting.marshal.http.HTTPUnMarshaller</classname>,
    which are distinct from their parent classes
    <classname>org.jboss.remoting.marshal.serializable.SerializableMarshaller</classname>
    and <classname>org.jboss.remoting.marshal.serializable.SerializableUnMarshaller</classname>
    only insofar as they treat Strings as a special case in the interest of efficiency.
    However, prior to release 2.5.2, <classname>HTTPUnMarshaller</classname> incorrectly
    uses the content-type set by the <classname>ServerInvocationHandler</classname> (if
    any), which would normally apply to the application payload of a response rather
    than the type of the envelope.  As of release 2.5.2, this behavior remains the
    default, but it can be corrected by setting the parameter 
    <code>org.jboss.remoting.transport.http.HTTPMetadataConstants.USE_REMOTING_CONTENT_TYPE</code>
    (actual value "useRemotingContentType") to "true".</para>

    <bridgehead>Compression marshalling</bridgehead>

    <para>A compression marshaller/unmarshaller is available as well which
    uses gzip to compress and uncompress large payloads for wire transfer. The
    implementation classes are
    <classname>org.jboss.remoting.marshal.compress.CompressingMarshaller</classname>
    and
    <classname>org.jboss.remoting.marshal.compress.CompressingUnMarshaller</classname>.
    They extend the
    <code>org.jboss.remoting.marshal.serializable.SerializableMarshaller</code>
    and
    <code>org.jboss.remoting.marshal.serializable.SerializableUnMarshaller</code>
    interfaces and maintain the same behavior with the addition of
    compression.</para>
  </section>

  <section id="section-callbacks" xreflabel="Callbacks">
    <title>Callbacks</title>

    <section>
      <title>Callback overview</title>

      <para>
        Although this section covers callback configuration, it will be useful
        to begin with a little general information about callbacks within
        Remoting. In addition to the ordinary remote method invocation model, in
        which invocation results are returned synchronously, Remoting also
        supports an invocation model in which the server asynchronously
        generates information to be returned to the client.
      </para>
      
      <para>
        There are two models for callbacks, <emphasis role="bold">push
        callbacks</emphasis> and <emphasis role="bold">pull
        callbacks</emphasis>. In the push model, the client registers a client
        side callback server with the target server. When the target server has
        a callback to deliver, it will call on the callback server directly and
        send the callback message. The other model, pull callbacks, allows the
        client to call on the target server to collect the callback messages
        waiting for it.
      </para>
            
      <section>
        <title>Callback connections</title>
        
        <para>
          A <emphasis role="bold">callback connection</emphasis> is initiated by
          the invocation of one of the overloaded
          <methodname>addListener()</methodname> methods in the
          <classname>org.jboss.remoting.Client</classname> class, as described
          below in Section <xref linkend="section-callback-handlers"/>. The
          creation of a callback connection results in a server side call to the
        </para>
        
        <programlisting>public void addListener(InvokerCallbackHandler callbackHandler);</programlisting>
        
        <para>
          method of the application's
          <classname>org.jboss.remoting.ServerInvocationHandler</classname>. The
          <classname>org.jboss.remoting.callback.InvokerCallbackHandler</classname>
          parameter (actual type
          <classname>org.jboss.remoting.callback.ServerInvokerCallbackHandler</classname>)
          is the server side representation of the callback connection,
          essentially a proxy for the client side
          <classname>InvokerCallbackHandler</classname> passed to the
          <methodname>addListener()</methodname> method. The
          <classname>ServerInvocationHandler</classname> is free to do whatever
          it wants with the <classname>InvokerCallbackHandler</classname>, but a
          typical practice would be to keep a list of them and transmit each
          generated callback to some or all of them.
        </para>
        
        <para>
          <emphasis role="bold">Note.</emphasis> As of release 2.5.1,
          <classname>ServerInvokerCallbackHandler</classname>
          has a new method, <methodname>shutdown()</methodname>, which can be used by, for example, the
          <classname>ServerInvocationHandler</classname> with which it is registered, or by an 
          <classname>org.jboss.remoting.ConnectionListener</classname> upon being informed of a 
          connection failure, to clean up the <classname>ServerInvokerCallbackHandler</classname>
          and references thereto.
        </para>
        
        <para>
          The client side of a callback connection is identified in one of two
          ways, according to whether there is a callback
          <classname>Connector</classname> associated with the connection. If
          the connection has a callback <classname>Connector</classname>, then
          it is identifed by the combination of the
          <classname>Connector</classname> and the
          <classname>InvokerCallbackHandler</classname>. It follows that if an
          <classname>InvokerCallbackHandler</classname> is registered twice with
          the same <classname>Connector</classname> (through a call to
          <methodname>Client.addListener()</methodname>), only a single callback
          connection is created. That is, the second call has no effect. If
          there is no callback <classname>Connector</classname>, which is the
          case for pull callbacks and simulated push callbacks (see Section
          <xref linkend="section-callback-handlers"/>), then the callback
          connection is identified by the combination of the
          <classname>Client</classname> on which
          <methodname>addListener()</methodname> was invoked and the
          <classname>InvokerCallbackHandler</classname>. It follows that if an
          <classname>InvokerCallbackHandler</classname> is registered twice with
          the same <classname>Client</classname> for pull or simulated push
          callbacks, only a single callback connection is created. That is, the
          second call has no effect.
        </para>
        
        <para>
          Each callback connection is tagged with a unique identifier, which can
          be retrieved from the <classname>InvokerCallbackHandler</classname>
          passed to
          <methodname>ServerInvocationHandler.addListener()</methodname> by
          casting it to type
          <classname>org.jboss.remoting.callback.ServerInvokerCallbackHandler</classname>
          and calling <methodname>getCallbackSessionId()</methodname>. It is
          also possible to retrieve the unique identifier of the
          <classname>Client</classname> upon which
          <methodname>addListener()</methodname> was invoked by casting the
          <classname>InvokerCallbackHandler</classname> to type
          <classname>ServerInvokerCallbackHandler</classname> and calling
          <methodname>getClientSessionId()</methodname>.
        </para>
      </section>
      
      <section>
        <title>Transmitting callbacks</title>
        
        <para>
          Once the <classname>ServerInvocationHandler</classname> has generated
          information to be sent to the client, it can be packaged in an
          <classname>org.jboss.remoting.callback.Callback</classname> and
          transmitted on one or more callback connections in one of two ways.
          One way to transmit a callback is by invoking the
        </para>
        
        <programlisting>public void handleCallback(Callback callback) throws HandleCallbackException;</programlisting>
        
        <para>
          method of <classname>InvokerCallbackHandler</classname>. The
          subsequent disposition of the callback depends on whether the callback
          connection is configured for push or pull callbacks. For a pull
          callback connection, the <classname>Callback</classname> is simply
          stored on the server, and for a push callback connection,
          <methodname>handleCallback()</methodname> is analogous to (and is
          implemented by) an ordinary <methodname>Client.invoke()</methodname>
          invocation.
        </para>
        
        <para>
          An alternative method of transmitting a callback is by casting an
          <classname>InvokerCallbackHandler</classname> to type
          <classname>org.jboss.remoting.callback.AsynchInvokerCallbackHandler</classname>
          and invoking one of the overloaded
          <methodname>handleCallbackOneway()</methodname> methods
        </para>
        
        <programlisting>public void handleCallbackOneway(Callback callback) throws HandleCallbackException;
  
public void handleCallbackOneway(Callback callback, boolean serverSide)
        throws HandleCallbackException;</programlisting>
        
        <para>
          of <classname>AsynchInvokerCallbackHandler</classname>. (Note that all
          <classname>InvokerCallbackHandler</classname>s passed in to
          <classname>ServerInvocationHandler.addListener()</classname> implement
          <classname>AsynchInvokerCallbackHandler</classname>.) For a pull
          callback connection <methodname>handleCallbackOneway()</methodname>
          has the same behavior as <methodname>handleCallback()</methodname>,
          but for a push callback connection it is analogous to (and implemented
          by) a <methodname>Client.invokeOneway()</methodname> invocation. The
          <code>serverSide</code> parameter is analogous to the
          <code>clientSide</code> parameter in the
        </para>
        
        <programlisting>public void invokeOneway(Object param, Map sendPayload, boolean clientSide) throws Throwable;</programlisting>
          
        <para>
          method of <classname>org.jboss.remoting.Client</classname>. That is,
          if <code>serverSide</code> is true, then the oneway invocation is
          handed off to a separate thread on the server side and the call to
          <methodname>handleCallbackOneway()</methodname> returns immediately.
          If <code>serverSide</code> is false, then callback
          <classname>Client</classname> makes an invocation on the callback
          server, which hands the invocation off to a separate thread on the
          client side and returns, after which the call to
          <methodname>handleCallbackOneway()</methodname> returns.
        </para>
      </section>
      
      <section>
        <title>Callback stores.</title>
        
        <para>
        For pull callbacks (and also simulated push callbacks - see Section
        <xref linkend="section-callback-handlers"/>), the
        server has to manage callback messages
        until the client calls to collect them. Since the server has no control
        of when the client will call to get the callbacks, it has to be aware of
        memory constraints as it manages a growing number of callbacks. The way
        the callback server does this is through use of a
        <emphasis role="bold">persistence policy</emphasis>.
        </para>
        
        <para>
        The persistence policy indicates at what point the server has too little
        free memory available and therefore the callback message should be put
        into a persistent store. This policy can be configured via the
        <code>memPercentCeiling</code> attribute (see more on configuring this
        below).</para>
        
        <para>By default, the persistent store used by the invokers is the
        <code>org.jboss.remoting.NullCallbackStore</code>. The NullCallbackStore
        will simply throw away the callback to help avoid running out of memory.
        When the persistence policy is triggered and the NullCallbackStore is
        called upon to store the callback, the invocation handler making the
        call will be thrown an IOException with the message:</para>
  
        <para><blockquote>Callback has been lost because not enough free memory to
        hold object.</blockquote></para>
  
        <para>and there will be an error in the log stating which object was
        lost. In this same scenario, the client will get an instance of the
        <code>org.jboss.remoting.NullCallbackStore.FailedCallback</code> class
        when they call to get their callbacks. This class will throw a
        RuntimeException with the following message when
        <code>getCallbackObject()</code> is called:</para>
  
        <para><blockquote>This is an invalid callback. The server ran out of
        memory, so callbacks were lost.</blockquote></para>
  
        <para>Also, the payload of the callback will be the same string. The
        client will also get any valid callbacks that were kept in memory before
        the persistence policy was triggered.</para>
  
        <para>An example case when using the NullCallbackStore might be when
        callback objects A, B, and C are stored in memory because there is
        enough free memory. Then when callback D comes, the persistence policy
        is triggered and the NullCallbackStore is asked to persist callback D.
        The NullCallbackStore will throw away callback D and create a
        FailedCallback object to take its place. Then callback E comes, and
        there is still too little free memory, so that is thrown away by the
        NullCallbackStore.</para>
  
        <para>Then the client calls to get its callbacks. It will receive a List
        containing callbacks A, B, C and the FailedCallback. When the client
        asks the FailedCallback for its callback payload, it will throw the
        aforementioned exception.</para>
  
        <para>Besides the default NullCallbackStore, there is a truly persistent
        CallbackStore, which will persist callback messages to disk so they will
        not be lost. The description of the CallbackStore is as follows:</para>
  
        <para><blockquote>Acts as a persistent list which writes Serializable
        objects to disk and will retrieve them in same order in which they were
        added (FIFO). Each file will be named according to the current time
        (using System.currentTimeMillis() with the file suffix specified (see
        Section <xref linkend="section-callback-store-configuartion"/>).
        When the object is read and returned by calling the getNext()
        method, the file on disk for that object will be deleted. If for some
        reason the store VM crashes, the objects will still be available upon
        next startup</blockquote></para>
        
        <para>CallbackStore is also a service mbean, so can be run as a service
        within JBoss AS or stand alone.</para>
        
        <para>Remoting also offers the
        <classname>BlockingCallbackStore</classname>, 
        which is described as follows.</para>
        
        <para><blockquote>
         This callback store does not persist callback messages when memory is
         running low, but instead will block the thread making the handle
         callback call from the server invoker. The intention is that this will
         throttle the server invoker from generating/sending any more callbacks
         until client as called to get the in-memory callbacks that have already
         been collected and memory has been released.
        </blockquote></para>

        <para>Custom callback stores can also be implemented and defined within
        configuration. The only requirement is that it implements the
        org.jboss.remoting.SerializableStore interface and has a void
        constructor (only in the case of using a fully qualified classname in
        configuration).</para>

        <para>Once a callback client has been removed as a listener, all
        persisted callbacks will be removed from disk.</para>
      
      </section>
      
      <section>
        <title>Callback acknowledgements</title>
        
        <para>
          Unlike the <methodname>Client.invoke()</methodname> method,
          <methodname>InvokerCallbackHandler.handleCallback()</methodname> has a
          void return type, so it does not provide a way of knowing if the
          callback has been received by the client. In fact, a void return type
          is appropriate since the immediate effect of a call to
          <methodname>InvokerCallbackHandler.handleCallback()</methodname> may
          be no more than storing the callback for later retrieval. However, it
          may be useful for the application to be informed when the callback has
          made its way to the client, and Remoting has a listener mechanism that
          can provide callback acknowledgements.
        </para>
        
        <para>
          An object that implements the
          <classname>org.jboss.remoting.callback.CallbackListener</classname> interface
        </para>
        
        <programlisting>public interface CallbackListener
{
   /**
    * @param callbackHandler InvokerCallbackHandler that handled this callback
    * @param callbackId id of callback being acknowledged
    * @param response either (1) response sent with acknowledgement or (2) null
    */
   void acknowledgeCallback(
           InvokerCallbackHandler callbackHandler, Object callbackId, Object response);
}</programlisting>
          
        <para>
          may be registered to receive an acknowledgement for a particular
          callback by adding it to the callback's <code>returnPayload</code> map
          with the key
          <code>org.jboss.remoting.callback.ServerInvokerCallbackHandler.CALLBACK_LISTENER</code>
          (actual value "callbackListener"). It is also necessary to assign an
          identifier to the callback by adding some unique object, recognizable
          by the application, to the callback's <code>returnPayload</code> map
          with the key <code>ServerInvokerCallbackHandler.CALLBACK_ID</code>
          (actual value "callbackId"). This identifier will be passed as the
          <code>callbackId</code> parameter of the
          <methodname>CallbackListener.acknowledgeCallback()</methodname>
          method.
        </para>
        
        <para>
          There are two ways in which callbacks can be acknowledged:
        </para>
        
        <orderedlist>
          <listitem>explicit acknowledgements, and</listitem>
          <listitem>automatic acknowledgements.</listitem>
        </orderedlist>
        
        <para>
          Note that automatic acknowledgements are available only for push
          callbacks and simulated push callbacks (see Section <xref
          linkend="section-callback-handlers"/>) transmitted by the
          <methodname>InvokerCallbackHandler.handleCallback()</methodname>
          method.
        </para>
        
        <para>
          Callbacks may be acknowledged explicitly by the client side
          application code by calling one of the overloaded
          <methodname>acknowledgeCallback()</methodname> and
          <methodname>acknowledgeCallbacks()</methodname> methods
        </para>
        
        <programlisting>public int acknowledgeCallback(
        InvokerCallbackHandler callbackHandler, Callback callback) throws Throwable;
           
public int acknowledgeCallback(
        InvokerCallbackHandler callbackHandler, Callback callback, Object response) throws Throwable;
           
public int acknowledgeCallbacks(
        InvokerCallbackHandler callbackHandler, List callbacks) throws Throwable;
           
public int acknowledgeCallbacks(
        InvokerCallbackHandler callbackHandler, List callbacks, List responses) throws Throwable;</programlisting>
        
        <para>
          of the <classname>Client</classname> class. In each case the
          <code>callbackHandler</code> parameter is the client side
          <classname>InvokerCallbackHandler</classname> which received the
          callback. The first two and the latter two methods acknowledge a
          single callback and a list of callbacks, respectively. In the latter
          case, each of the callbacks must have the same registered
          <classname>CallbackListener</classname>. The second and fourth methods
          also allow a response value to be associated with each callback
          acknowledgement, which will passed as the <code>response</code>
          parameter of the
          <methodname>CallbackListener.acknowledgeCallback()</methodname>
          method. For the fourth method, the lengths of the
          <code>callbacks</code> list and the <code>responses</code> list must
          be the same.
        </para>
        
        <para>
          It is also possible to request that Remoting automatically supply
          acknowledgements for push callbacks and simulated push callbacks by
          adding the key
          <code>ServerInvokerCallbackHandler.REMOTING_ACKNOWLEDGES_PUSH_CALLBACKS</code>
          (actual value "remotingAcknowledgesPushCallbacks") to the callback's
          <code>returnPayload</code> map with the value of true, along with the
          <code>ServerInvokerCallbackHandler.CALLBACK_LISTENER</code> and
          <code>ServerInvokerCallbackHandler.CALLBACK_ID</code> entries. The
          acknowledgement is generated after the callback has been delivered by
          a call to <methodname>handleCallback()</methodname> on the client side
          <methodname>InvokerCallbackHandler</methodname>.
        </para>
        
        <para>
          For an example of code that uses callback acknowledgements, see the
          classes in the package
          <code>org.jboss.remoting.samples.callback.acknowledgement</code>.
        </para>
        
      </section>
   </section>
    
    <section id="section-callback-handlers" xreflabel="Registering callback handlers">
    
      <title>Registering callback handlers.</title>
      
      <para>There are several ways in which callback handlers can be configured.
      The main distinction in type of callback setup is whether the callbacks
      will be push (asynchronous) or pull (synchronous) callbacks.</para>
      
      <section id="subsection-pull-callbacks" xreflabel="Pull callbacks">
        <title>Pull callbacks.</title>
        
        <para>
          A pull callback connection is implemented by an object (an
         <classname>org.jboss.remoting.callback.ServerInvokerCallbackHandler</classname>)
         on the server side which stores information that is generated
         asynchronously on the server and subsequently retrieved by the client.
         It is set up by invoking one of the following overloaded
         <methodname>addListener()</methodname> methods in the
         <classname>Client</classname> class:
       </para>
        
        <programlisting>public void addListener(
        InvokerCallbackHandler) throws Throwable;
          
public void addListener(
        InvokerCallbackHandler callbackHandler, InvokerLocator clientLocator) throws Throwable;
          
public void addListener(
        InvokerCallbackHandler callbackHandler,  InvokerLocator clientLocator,
        Object callbackHandlerObject) throws Throwable;</programlisting>
        
        <para>
          where, in the latter two cases, the <code>clientLocator</code> parameter is set to null.  
        </para>
        
        <para>
          The callbacks stored for a pull callback connection may be retrieved by calling the
        </para>
        
        <programlisting>public List getCallbacks(InvokerCallbackHandler callbackHandler) throws Throwable</programlisting>
        
        <para>
          method of the <classname>Client</classname> class. Note that for pull
          callbacks, the <classname>InvokerCallbackHandler</classname>
          registered on the client side doesn't really participate in the
          handling of callbacks. However, when
          <methodname>client.getCallbacks(callbackHandler)</methodname> is
          called for a particular <classname>Client</classname> and
          <classname>InvokerCallbackHandler</classname>, the two objects
          together identify a particular callback connection.
        </para>
        
        <para><emphasis role="bold">Note. </emphasis>As of Remoting version 2.4
        there are two versions of pull callbacks: non-blocking (original) and
        blocking (new). [The new version has been ported to Remoting release
        2.2.2.GA, so it exists in later versions of the 2.2 family]. In the
        original, non-blocking mode, a call to
        <classname>Client.getCallbacks()</classname> will return more or less
        immediately, whether or not any callbacks are waiting on the server
        side. In the new, blocking mode, the call will block on the server side
        until either it times out or a callback becomes available. The blocking
        mode eliminates the overhead of busy polling. Blocking and non-blocking
        mode are configured on a per-invocation basis by setting
        <code>org.jboss.remoting.ServerInvoker.BLOCKING_MODE</code> (actual
        value "blockingMode") to either
        <classname>ServerInvoker.BLOCKING</classname> (actual value "blocking")
        or <classname>ServerInvoker.NONBLOCKING</classname> (actual value
        "nonblocking") in the metadata map passed to</para>
        
        <programlisting>public List getCallbacks(
        InvokerCallbackHandler callbackHandler, Map metadata) throws Throwable;</programlisting>
        
        <para>in <classname>org.jboss.remoting.Client</classname>. The default
        value is <code>ServerInvoker.NONBLOCKING</code>. The blocking timeout value
        may be configured in two ways:</para>
        
        <orderedlist>
           <listitem><para>the <classname>Connector</classname> can be
           configured with a default value; and</para>
           </listitem>
           <listitem><para>a per-invocation timeout value can be configured with
           the key <code>ServerInvoker.BLOCKING_TIMEOUT</code> in the metadata
           map passed to <methodname>Client.getCallbacks()</methodname>.</para>
           </listitem>
        </orderedlist>
        
        <para>In the absence of any configured timeout, the default value is 5000 ms.</para>
    
      </section>
      
      <section>
        <title>Push callbacks.</title>
        
        <para>
          A push callback connection is implemented by a pair of objects, one on
          the server side and one on the client side, which facilitate
          transmitting to the client some information which has been generated
          asynchronously on the server. There are two versions of push
          callbacks: <emphasis role="bold">true push callbacks</emphasis> and
          <emphasis role="bold">simulated push callbacks</emphasis>, also known
          as <emphasis role="bold">polled callbacks</emphasis>.
        </para>
          
        <para>
          In the case of true push callbacks, there is a Remoting object on the
          server side (an <classname>org.jboss.remoting.callback.ServerInvokerCallbackHandler</classname>)
          which uses a <classname>Client</classname> to make
          invocations to the client side. On the client side there is a
          <classname>Connector</classname> and an implementation of the
          <classname>org.jboss.remoting.callback.InvokerCallbackHandler</classname>
          interface which functions as an invocation handler for callbacks. Like 
          implementations of
          <classname>org.jboss.remoting.ServerInvocationHandler</classname> on
          the server side, implementations of 
          <classname>InvokerCallbackHandler</classname> are supplied by
          the application. When a <classname>ServerInvocationHandler</classname>
          generates a callback object, it will be sent to the callback
          <classname>Connector</classname>, which will, in turn, deliver it to 
          the <classname>InvokerCallbackHandler</classname>
        </para>
        
        <para>
          For simulated push callbacks, the server side Remoting object stores
          callbacks for later retrieval by the client, exactly as in the case of
          pull callbacks. However, there is a Remoting poller (an
          <classname>org.jboss.remoting.callback.CallbackPoller</classname>) on
          the client side which periodically retrieves the callbacks and, as in
          the case of true push callbacks, delivers them to the
          <classname>InvokerCallbackHandler</classname>.
        </para>
        
        <para>
          There are two ways to set up push callback handling, each of which
          entails the use of one of the overloaded
          <methodname>addListener()</methodname> methods in the
          <classname>Client</classname> class:
        </para>

        <orderedlist>
          <listitem>explicit creation of a <classname>Connector</classname>
          </listitem>
          
          <listitem>implicit configuration.
          </listitem>
        </orderedlist>
        
        <para>
          In the first case, the application creates a <classname>Connector</classname>
          and passes its <classname>InvokerLocator</classname>, along with an
          implementation of <classname>InvokerCallbackHandler</classname>, to
          one of the following versions of
          <methodname>addListener()</methodname>:
        </para>
        
        <programlisting>public void addListener(
        InvokerCallbackHandler callbackHandler, InvokerLocator clientLocator) throws Throwable;
          
public void addListener(
        InvokerCallbackHandler callbackHandler,InvokerLocator clientLocator,
        Object callbackHandlerObject) throws Throwable;</programlisting>
        
        <para>
          Because there is a <classname>Connector</classname>, explicit configuration always results in true push callbacks.
        </para>
          
        <para>
          In the case of implicit configuration, only the
         <classname>InvokerCallbackHandler</classname> is passed and Remoting
         takes care of the rest. One of the following versions of
         <methodname>addListener()</methodname> is used:
        </para>
                
        <programlisting>public void addListener(
        InvokerCallbackHandler callbackhandler, Map metadata) throws Throwable;
          
public void addListener(
        InvokerCallbackHandler callbackhandler, Map metadata,
        Object callbackHandlerObject) throws Throwable;
          
public void addListener(
        InvokerCallbackHandler callbackhandler, Map metadata,
        Object callbackHandlerObject, boolean serverToClient) throws Throwable;</programlisting>   
  
        <para>
          Note that the latter three methods are distinguished from the first
          two by the presence of the <code>metadata</code> parameter, which can
          be used to configure the callback connection. Depending on the
          transport being used and the parameters supplied to
          <methodname>addListener()</methodname>, Remoting will set up either
          true or simulated push callbacks. If the client is in an environment
          where the server will be allowed to establish a connection to the
          client, then the final version of
          <methodname>addLIstener()</methodname> could be used with the
          <code>serverToClient</code> parameter set to true. In this case,
          regardless of the transport, Remoting will automatically create a
          callback <classname>Connector</classname> on behalf of the user, which
          behaves just as though the user had created it and passed the
          <classname>InvokerLocator</classname> as a parameter to
          <methodname>addListener()</methodname>.
        </para>
        
        <para><emphasis role="bold">Note.</emphasis> Since release 2.5.1, if the first instance
          of the parameter <code>org.jboss.remoting.Client.USE_ALL_PARAMS</code>
          (actual value "useAllParams") found successively in the <classname>InvokerLocator</classname>, the
          <classname>Client</classname>'s configuration map, or the metadata map is set
          to "true", then polled callbacks can be configured by parameters in the 
          <classname>InvokerLocator</classname> and <classname>Client</classname>'s 
          configuration map as well as the metadata map passed to <methodname>addListener()</methodname>.
        </para>
               
        <para>
          If the client is in an environment where the server is not allowed to
          establish a network connection to the client (e.g. firewall rules
          disallow it or security rules prohibit the creation of a
          <classname>ServerSocket</classname>), then there are two options. One
          is to use one of the <emphasis role="bold">bidirectional</emphasis>
          transports, each of which has a strategy for the creation of a
          connection from the server to the client without connecting a client
          <classname>Socket</classname> to a
          <classname>ServerSocket</classname>. There are currently three
          bidirectional transports: local (i.e., the client and server reside in
          the same JVM), bisocket, and multiplex (deprecated). When one of the
          second set of <methodname>addListener()</methodname> methods is
          invoked for a bidirectional transport, it will create a callback
          <classname>Connector</classname>, even if <code>serverToClient</code>
          is set to false. The other option is to use any of the <emphasis
          role="bold">unidirectional</emphasis> transports (socket, http, rmi)
          with <code>serverToClient</code> set to false (which is the default
          value if it is not an explicit parameter), in which case, Remoting
          will configure polled callbacks.
        </para>
        
        <para>
          The implicitly created callback <classname>Connectors</classname> are
          available for reuse. Each <classname>Client</classname> maintains a
          set of all callback <classname>Connector</classname>s it has implicitly
          created for each <classname>InvokerCallbackHandler</classname> that is
          passed in by way of one of the <methodname>addListener()</methodname>
          methods. For example,
        </para>
        
        <programlisting>InvokerCallbackHandler callbackHandler = new SampleCallbackHandler();
client.addListener(callbackHandler, new HashMap(), null, true);
client.addListener(callbackHandler, new HashMap(), null, true);</programlisting>
        
        <para>
          would result in a set of two callback
          <classname>Connector</classname>s associated with
          <code>callbackHandler</code>.  These sets of callback
          <classname>Connector</classname>s are accessible by way of the
          <classname>Client</classname> method
        </para>
        
        <programlisting>public Set getCallbackConnectors(InvokerCallbackHandler callbackHandler);</programlisting>
        
        <para>
          A callback <classname>Connector</classname> could be reused as in the
          following code:
        </para>
        
        <programlisting>InvokerCallbackHandler callbackHandler1 = new SampleCallbackHandler();
client.addListener(callbackHandler1, new HashMap(), null, true);
Set callbackConnectors = client.getCallbackConnectors(callbackHandler1);
Connector callbackConnector = (Connector) callbackConnectors.iterator().next();
InvokerCallbackHandler callbackHandler2 = new SampleCallbackHandler();
client.addListener(callbackHandler2, callbackConnector.getLocator());</programlisting>
        
        <para>
          which would result in the implicitly created callback
          <classname>Connector</classname> having two registered
          <classname>InvokerCallbackHandler</classname>s.  Note, by the way, that
          if the <classname>InvokerCallbackHandler</classname> were reused as in
          the following:
        </para>
        
        <programlisting>InvokerCallbackHandler callbackHandler1 = new SampleCallbackHandler();
client.addListener(callbackHandler1, new HashMap(), null, true);
Set callbackConnectors = client.getCallbackConnectors(callbackHandler1);
Connector callbackConnector = (Connector) callbackConnectors.iterator().next();
client.addListener(callbackHandler1, callbackConnector.getLocator());</programlisting>
        
        <para>
          then only one callback connection would be created, because a single
          (<classname>Connector</classname>,
          <classname>InvokerCallbackHandler</classname>) pair can be associated
          with only one callback connection.
        </para>
        
        <para><emphasis role="bold">Note. </emphasis>As of Remoting version 2.4,
        there are two versions of pull callbacks: non-blocking (original) and
        blocking (new). For more information, see <xref
        linkend="subsection-pull-callbacks"/>. Since the
        <classname>CallbackPoller</classname> uses pull callbacks, this
        distinction is relevant to polled callbacks as well. The default
        behavior of <classname>CallbackPoller</classname> is to use non-blocking
        mode, but blocking mode can be requested by using the key
        <code>ServerInvoker.BLOCKING_MODE</code> set to
        <code>ServerInvoker.BLOCKING</code> in the metadata map passed to
        <methodname>Client.addListener()</methodname>.</para>
        
        <para>
          There are nine parameters that can be passed to
          <methodname>Client.addListener()</methodname> in the
          <code>metadata</code> map which are specific to push callback
          configuration. The first three apply to push callbacks and the latter
          six apply to polled callbacks. For convenience, the keys related to
          push callbacks are defined as constants in the
          <classname>org.jboss.remoting.Client</classname> class, and the keys
          related to polled callbacks are defined in the
          <classname>org.jboss.remoting.callback.CallbackPoller</classname>
          class (with the exception of
          <code>ServerInvoker.BLOCKING_MODE</code> and <code>ServerInvoker.BLOCKING_TIMEOUT</code>).
        </para>

          <para>
            <emphasis role="bold">CALLBACK_SERVER_PROTOCOL</emphasis> (actual
            value is "callbackServerProtocol): the transport protocol to be used
            for callbacks. By default it will be the protocol used by the
            <classname>Client</classname> upon which
            <methodname>addListener()</methodname> is invoked.
          </para>
          
          <para>
            <emphasis role="bold">CALLBACK_SERVER_HOST</emphasis> (actual value
            is "callbackServerHost"): the host name to be used by the callback
            server. By default it will be the result of calling
            <methodname>InetAddress.getLocalHost().getHostAddress()</methodname>.
          </para>
          
          <para>
            <emphasis role="bold">CALLBACK_SERVER_PORT</emphasis> (actual value
            is "callbackServerPort"): the port to be used by the callback
            server. By default it will be a randomly chosen unused port.
          </para>
          
          <para>
            <emphasis role="bold">CALLBACK_POLL_PERIOD</emphasis> (actual value
            is "callbackPollPeriod"): the interval in milliseconds between
            attempts to download callbacks from the server.
          </para>
          
          <para>
            <emphasis role="bold">CALLBACK_SCHEDULE_MODE</emphasis> (actual
            value is "scheduleMode"): may be set to either
            <code>CallbackPoller.SCHEDULE_FIXED_RATE</code> (actual value
            "scheduleFixedRate") or
            <code>CallbackPoller.SCHEDULE_FIXED_DELAY</code> (actual value
            "scheduleFixedDelay"). In either case, polling will take place at
            approximately regular intervals, but in the former case the
            scheduler will attempt to perform each poll CALLBACK_POLL_PERIOD
            milliseconds after the previous attempt, and in the latter case the
            scheduler will attempt to schedule polling so that the
            <emphasis>average</emphasis> interval will be approximately
            CALLBACK_POLL_PERIOD milliseconds.
            <code>CallbackPoller.SCHEDULE_FIXED_RATE</code> is the default.
          </para>
          
          <para>
            <emphasis role="bold">REPORT_STATISTICS</emphasis> (actual value is
            "reportStatistics"): The presence of this key in
            <code>metadata</code>, regardless of its value, will cause the
            <classname>CallbackPoller</classname> to print statistics that might
            be useful for configuring the other parameters..
          </para>
          
          <para>
            <emphasis role="bold">MAX_ERROR_COUNT</emphasis> (actual value is
            "maxErrorCount"): determines the maximum number of errors that may
            be experienced during polling before
            <classname>CallbackPoller</classname> will shut itself down. The
            default value is "5".
          </para>          

          <para>
            <emphasis role="bold">SYNCHRONIZED_SHUTDOWN</emphasis> (actual value
            is "doSynchronizedShutdown"): if set to "true",
            <methodname>CallbackPoller.stop()</methodname> will wait for
            <methodname>Client.getCallbacks()</methodname> to return, and if set
            to "false" it will not wait. For blocking polled callbacks, the
            default value is "false" and for non-blocking polled callbacks, the
            default value is "true".
          </para>
          
          <para>
            <emphasis role="bold">BLOCKING_MODE</emphasis> (actual value is
            "blockingMode"): if set to <code>ServerInvoker.BLOCKING</code>
            (actual value "blocking"), <classname>CallbackPoller</classname>
            will do blocking polled callbacks, and if set to
            <code>ServerInvoker.NONBLOCKING</code> (actual value "nonblocking"),
            <classname>CallbackPoller</classname> will do non-blocking polled
            callbacks.
          </para>
          
          <para>
            <emphasis role="bold">BLOCKING_TIMEOUT</emphasis> (actual value is
            "blockingTimeout"): the value is used as the per-invocation timeout
          </para>
          
        <para>
          Note that all of the elements in <code>metadata</code> will be passed
         to the callback <classname>Connector</classname> and appended to its
         <classname>InvokerLocator</classname>.
       </para>
       
       <para><emphasis role="bold">Note. </emphasis> As of Remoting version 2.4,
       it is possible to configure a server side timeout value for sending push
       callbacks that is distinct from the timeout value used by the server.
       [This feature has been ported to Remoting release 2.2.2.GA, so it exists
       in later versions of the 2.2 family]. The parameter is
       <code>org.jboss.remoting.callback.ServerInvokerCallbackHandler.CALLBACK_TIMEOUT</code>
       (actual value "callbackTimeout"), and it should be used to configure the
       <classname>Connector</classname>. In the absence of
       <code>ServerInvokerCallbackHandler.CALLBACK_TIMEOUT</code>, the timeout
       value configured for the <classname>Connector</classname> will be
       used.</para>
       
      </section>
      
    </section>
    
    <section>
      <title>Unregistering callback handlers</title>
      
      <para>
        Callback connections are torn down through a call to the method
      </para>
      
      <programlisting>public void removeListener(InvokerCallbackHandler callbackHandler) throws Throwable;</programlisting>
      
      <para>
        in the <classname>org.jboss.remoting.Client</classname> class. A
        <classname>Client</classname> can unregister only those
        <classname>InvokerCallbackHandler</classname>s that it originally
        registered.
      </para>
        
      <para>
        It is good practice to eliminate callback connections when they are no
        longer needed. For example, callback <classname>Connector</classname>s
        can, depending on the transport, occupy TCP ports, and
        <classname>CallbackPoller</classname>s will continue to poll as long as
        a connection exists.
      </para>
      
    </section>

    <section id="section-callback-store-configuartion"
      xreflabel="Callback store configuration">
      <title>Callback store configuration.</title>
      
      <para>All callback store configuration will need to be defined within the
      server invoker configuration, since the server invoker is the parent that
      creates the callback stores as needed (when client registers for pull
      callbacks). Example service xml files are included below.</para>
      
      <para>The following general callback store parameters may be configured.
      They are defined as constants in the
      <classname>org.jboss.callback.ServerInvokerCallbackHandler</classname>
      class.</para>

      <para><emphasis role="bold">CALLBACK_MEM_CEILING</emphasis> (actual value
      is "callbackMemCeiling"): the
      percentage of free memory available before callbacks will be persisted.
      If the memory heap allocated has reached its maximum value and the
      percent of free memory available is less than the callbackMemCeiling,
      this will trigger persisting of the callback message. The default value
      is 20.</para>

      <para>Note: The calculations for this is not always accurate. The reason
      is that total memory used is usually less than the max allowed. Thus,
      the amount of free memory is relative to the total amount allocated at
      that point in time. It is not until the total amount of memory allocated
      is equal to the max it will be allowed to allocate. At this point, the
      amount of free memory becomes relevant. Therefore, if the memory
      percentage ceiling is high, it might not trigger until after free memory
      percentage is well below the ceiling.</para>

      <para><emphasis role="bold">CALLBACK_STORE_KEY</emphasis> (actual value
      is "callbackStore"): specifies the
      callback store to be used. The value can be either an MBean ObjectName
      or a fully qualified class name. If using class name, the callback store
      implementation must have a void constructor. The default is to use the
      NullCallbackStore.</para>

      <para>The following parameters specific to <classname>CallbackStore</classname>
      can be configured via the invoker configuration as well.  They are
      defined as constants in the <classname>CallbackStore</classname>
      class.</para>

      <para><emphasis role="bold">FILE_PATH_KEY</emphasis> (actual value is 
      "StoreFilePath"): indicates to
      which directory to write the callback objects. The default value is the
      property value of 'jboss.server.data.dir' and if this is not set, then
      will be 'data'. Will then append 'remoting' and the callback client's
      session id. An example would be
      'data\remoting\5c4o05l-9jijyx-e5b6xyph-1-e5b6xyph-2'.</para>

      <para><emphasis role="bold">FILE_SUFFIX_KEY</emphasis> (actual value is
      "StoreFileSuffix"): indicates the file suffix to use for the callback
      objects written to disk. The default value is 'ser'.</para>

      <bridgehead>Sample service configuration</bridgehead>
<para>Socket transport with callback store specified by class name and
      memory ceiling set to 30%:</para>

      <programlisting>&lt;mbean code="org.jboss.remoting.transport.Connector"
       name="jboss.remoting:service=Connector,transport=Socket"
       display-name="Socket transport Connector"&gt;

   &lt;attribute name="Configuration"&gt;
      &lt;config&gt;
         &lt;invoker transport="socket"&gt;
            &lt;attribute name="callbackStore"&gt;
               org.jboss.remoting.callback.CallbackStore
            &lt;/attribute&gt;
            &lt;attribute name="callbackMemCeiling"&gt;30&lt;/attribute&gt;
         &lt;/invoker&gt;
         &lt;handlers&gt;
            &lt;handler subsystem="test"&gt;
               org.jboss.remoting.callback.pull.memory.CallbackInvocationHandler
            &lt;/handler&gt;
         &lt;/handlers&gt;
      &lt;/config&gt;
   &lt;/attribute&gt;
&lt;/mbean&gt;</programlisting>

      <para>Socket transport with callback store specified by MBean ObjectName
      and declaration of CallbackStore as service:</para>

      <programlisting>&lt;mbean code="org.jboss.remoting.callback.CallbackStore"
       name="jboss.remoting:service=CallbackStore,type=Serializable"
       display-name="Persisted Callback Store"&gt;

   &lt;!-- the directory to store the persisted callbacks into --&gt;
   &lt;attribute name="StoreFilePath"&gt;callback_store&lt;/attribute&gt;
   &lt;!-- the file suffix to use for each callback persisted to disk --&gt;
   &lt;attribute name="StoreFileSuffix"&gt;cbk&lt;/attribute&gt;
&lt;/mbean&gt;

&lt;mbean code="org.jboss.remoting.transport.Connector"
       name="jboss.remoting:service=Connector,transport=Socket"
       display-name="Socket transport Connector"&gt;

   &lt;attribute name="Configuration"&gt;
      &lt;config&gt;
         &lt;invoker transport="socket"&gt;
            &lt;attribute name="callbackStore"&gt;
               jboss.remoting:service=CallbackStore,type=Serializable
            &lt;/attribute&gt;
         &lt;/invoker&gt;
         &lt;handlers&gt;
            &lt;handler subsystem="test"&gt;
               org.jboss.remoting.callback.pull.memory.CallbackInvocationHandler
            &lt;/handler&gt;
         &lt;/handlers&gt;
      &lt;/config&gt;
   &lt;/attribute&gt;
&lt;/mbean&gt;</programlisting>

      <para>Socket transport with callback store specified by class name and
      the callback store's file path and file suffix defined:</para>

      <programlisting>&lt;mbean code="org.jboss.remoting.transport.Connector"
       name="jboss.remoting:service=Connector,transport=Socket"
       display-name="Socket transport Connector"&gt;

   &lt;attribute name="Configuration"&gt;
      &lt;config&gt;
         &lt;invoker transport="socket"&gt;
            &lt;attribute name="callbackStore"&gt;
               org.jboss.remoting.callback.CallbackStore
            &lt;/attribute&gt;
            &lt;attribute name="StoreFilePath"&gt;callback&lt;/attribute&gt;
            &lt;attribute name="StoreFileSuffix"&gt;cst&lt;/attribute&gt;
         &lt;/invoker&gt;
         &lt;handlers&gt;
            &lt;handler subsystem="test"&gt;
               org.jboss.remoting.callback.pull.memory.CallbackInvocationHandler
            &lt;/handler&gt;
         &lt;/handlers&gt;
      &lt;/config&gt;
   &lt;/attribute&gt;
&lt;/mbean&gt;</programlisting>
    </section>

    <section>
      <title>Callback Exception Handling</title>

      <para>Since performing callbacks can sometimes fail, due to network
      errors or errors produced by the client callback handler, there needs to
      be a mechanism for managing exceptions when delivering callbacks. This
      is handled via use of the
      <code>org.jboss.remoting.callback.CallbackErrorHandler</code> interface.
      Implementations of this interface can be registered with the Connector
      to control the behavior when callback exceptions occur.</para>

      <para>The implementation of the CallbackErrorHandler interface can be
      specified by setting the 'callbackErrorHandler' attribute to either the
      ObjectName of an MBean instance of the CallbackErrorHandler which is
      already running and registered with the MBeanServer, or can just specify
      the fully qualified class name of the CallbackErrorHandler
      implementation (which will be constructed on the fly and must have a
      void parameter constructor). The full server invoker configuration will
      be passed along to the CallbackErrorHandler, so if want to add extra
      configuration information in the invoker's configuration for the
      callback error handler, it will be available. If no callback error
      handler is specified via configuration,
      <code>org.jboss.remoting.callback.DefaultCallbackErrorHandler</code>
      will be used by default. This implementation will allow up to 5
      exceptions to occur when trying to deliver a callback message from the
      server to the registered callback listener client (regardless of what
      the cause of the exception is, so could be because could not connect or
      could be because the client actually threw a valid exception). After the
      DefaultCallbackErrorHandler receives its fifth exception, it will remove
      the callback listener from the server invoker handler and shut down the
      callback listener proxy on the server side. The number of exceptions the
      DefaultCallbackErrorHandler will allow before removing the listener can
      by configured by the 'callbackErrorsAllowed' attribute.</para>
      
      <para><emphasis role="bold">Note. </emphasis>As of Remoting version 2.4,
      an
      <classname>org.jboss.remoting.callback.ServerInvokerCallbackHandler</classname>,
      which manages both push and pull callbacks on the server side, can
      register to be informed of a failure on the connection to the client that
      it is servicing. In particular, if there is a lease registered for the
      connection for that particular client, then the
      <classname>ServerInvokerCallbackHandler</classname> can be registered as a
      <classname>org.jboss.remoting.ConnectionListener</classname> for that
      lease. The default behavior is to do the registration, but the parameter
      <code>org.jboss.remoting.ServerInvoker.REGISTER_CALLBACK_LISTENER</code>
      (actual value "registerCallbackListener") may be set to "false" to prevent
      registration. If leasing is enabled and registration is turned on, a
      <classname>ServerInvokerCallbackHandler</classname> will shut itself down upon being informed of a connection
      failure. For more information about leasing, see <xref
      linkend="chapter-connection-failure"/>.</para>
    </section>
  </section>

  <!--
    <section>
      <title>Programmatic configuration</title>

      <para>It is possible to configure all this programmatically, if running
      outside the JBoss Application server for example, but is a little more
      tedious. Since the remoting components are all bound together by the
      <code>org.jboss.remoting.transport.Connector</code> class, will need to
      call its <code>setConfiguration(org.w3c.dom.Element xml)</code> method
      with same xml as in the mbean service configuration, before calling its
      <code>start()</code> method.</para>

      <para>The xml passed to the Connector should have
      <code>&lt;config&gt;</code> element as the root element and continue
      from there with <code>&lt;invoker&gt;</code> sub-element and so on. An
      example of this can be found in
      org.jboss.test.remoting.configuration.SocketClientConfigurationTestCase.</para>
    </section>  -->

  <section id="section-socket-factories"
           xreflabel="Socket factories and server socket factories">
    <title>Socket factories and server socket factories</title>

    <para>All current transports depend on sockets and server sockets, and the
    ability to specify their implementation classes provides considerable
    power in configuring Remoting. Notably, SSL sockets and server sockets are
    the basis of secure communications in Remoting. This section covers the
    configuration of socket factories and server socket factories on both the
    server side and the client side, and then focuses on SSL
    configuration.</para>

    <section>
      <title>Server side programmatic configuration</title>

      <para>All server invokers use server sockets, and it makes sense,
      therefore, to be able to configure server invokers with server socket
      factories. It is also true, though less obvious. that server invokers
      create sockets (other than by way of server sockets). When a server
      invoker makes a push callback to a client, it creates a client invoker,
      which creates a socket. Moreover, some server invokers, e.g., the RMI
      server invoker, have their own idiosyncratic uses for socket factories.
      Remoting offers a number of ways of configuring socket factories and
      server socket factories, and these apply to all transports (except for
      the servlet invokers).</para>

      <section id="section-ssf-serverside" xreflabel="Server socket factories">
        <title>Server socket factories.</title>

        <para>For <classname>ServerSocketFactory</classname>s, there are ten
        options for programmatic configuration:</para>

        <orderedlist>
          <listitem>
            <para>Get the <classname>ServerInvoker</classname> by calling
            <methodname>Connector.getServerInvoker()</methodname> and call
            <methodname>ServerInvoker.setServerSocketFactory()</methodname>.</para>
          </listitem>

          <listitem>
            <para>Call
            <methodname>Connector.setServerSocketFactory()</methodname>.</para>
          </listitem>

          <listitem>
            <para>Put a constructed <classname>ServerSocketFactory</classname>
            in a configuration map, using key
            <constant>Remoting.CUSTOM_SERVER_SOCKET_FACTORY</constant>, and
            pass the map to one of the <classname>Connector</classname>
            constructors.</para>
          </listitem>

          <listitem>
            <para>Create an xml document with root element
            <code>&lt;config&gt;</code>, setting the
            <code>&lt;serverSocketFactory&gt;</code> attribute to the name of
            a <classname>ServerSocketFactoryMBean</classname> and pass the
            document to <methodname>Connector.setConfiguration()</methodname>.
            For example: <programlisting>StringBuffer buf = new StringBuffer();
buf.append("&lt;?xml version=\"1.0\"?&gt;\n");
buf.append("&lt;config&gt;");
buf.append("   &lt;invoker transport=\"sslsocket\"&gt;");
buf.append("      &lt;attribute name=\"serverBindAddress\"&gt;" + getHostName() + "&lt;/attribute&gt;");
buf.append("      &lt;attribute name=\"serverBindPort\"&gt;" + freeport + "&lt;/attribute&gt;");
buf.append("      &lt;attribute name=\"serverSocketFactory\"&gt;" + socketFactoryObjName + "&lt;/attribute&gt;");
buf.append("   &lt;/invoker&gt;");
buf.append("&lt;/config&gt;");

ByteArrayInputStream bais = new ByteArrayInputStream(buf.toString().getBytes());
Document xml = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(bais);
connector.setConfiguration(xml.getDocumentElement());</programlisting></para>
          </listitem>

          <listitem>
            <para>Create an xml document with root element
            <code>&lt;config&gt;</code>, setting the
            <code>&lt;serverSocketFactory&gt;</code> attribute to the class
            name of a <classname>ServerSocketFactory</classname> and pass the
            document to <methodname>Connector.setConfiguration()</methodname>.
            The <code>&lt;serverSocketFactory&gt;</code> class must have a
            default constructor, which will be used to create a
            <classname>ServerSocketFactory</classname>.</para>
          </listitem>

          <listitem>
            <para>Put the <classname>ObjectName</classname> of a
            <classname>ServerSocketFactoryMBean</classname> in a configuration
            map, using key
            <constant>ServerInvoker.SERVER_SOCKET_FACTORY</constant>, and pass
            the map to one of the <classname>Connector</classname>
            constructors.</para>
          </listitem>

          <listitem>
            <para>Put the class name of a
            <classname>ServerSocketFactory</classname> in a configuration map,
            using key
            <constant>ServerInvoker.SERVER_SOCKET_FACTORY</constant>, and pass
            the map to one of the <classname>Connector</classname>
            constructors. The <code>&lt;serverSocketFactory&gt;</code> class
            must have a default constructor, which will be used to create a
            <classname>ServerSocketFactory</classname>.</para>
          </listitem>

          <listitem>
            <para>Put a set of SSL parameters, using the keys in
            <classname>org.jboss.remoting.security.SSLSocketBuilder</classname>,
            in a configuration map and pass the map to one of the
            <classname>Connector</classname> constructors. These will be used
            by <classname>SSLSocketBuilder</classname> (see below) to create a
            <classname>CustomSSLServerSocketFactory</classname>.</para>
          </listitem>

          <listitem>
            <para>Configure an appropriate set of SSL system properties and
            use one of the SSL transports (https, sslrmi, or
            sslsocket). The properties will be used to create some kind of
            <classname>SSLServerSocketFactory</classname>, as determined by
            the transport.</para>
          </listitem>

          <listitem>
            <para>Use one of the non-SSL transports and do nothing. A default
            <classname>ServerSocketFactory</classname> will be
            constructed.</para>
          </listitem>
        </orderedlist>

        <para>These options are essentially in descending order of precedence.
        If options 3 and 6, for example, are both used, the factory passed in
        option 3 will prevail. Options 4 and 5 are mutually exclusive, as are
        options 6 and 7. Options 1, 2, 3, 5, and 7 are illustrated in
        <classname>FactoryConfigSample</classname> and options 4, 6, 8, and 9
        are illustrated in <classname>FactoryConfigSSLSample</classname>, both
        of which are in package
        <classname>org.jboss.remoting.samples.config.factories</classname>.</para>

        <para><emphasis role="bold">Timing considerations.</emphasis> The
        <classname>ServerInvoker</classname>, for any transport, is created
        during the call to <methodname>Connector.create()</methodname>, before
        which option 1 is unavailable. Option 2, on the other hand, is only
        available before the call to
        <methodname>Connector.create()</methodname>. Once the
        <classname>ServerInvoker</classname> has been created, it selects a
        <classname>ServerSocketFactory</classname>, according to the rules
        enumerated above, during the <methodname>create()</methodname> phase.
        For all current transports, the actual
        <classname>ServerSocket</classname> is created during the call to
        <methodname>Connector.start()</methodname>, so that a call to
        <methodname>ServerInvoker.setServerSocketFactory()</methodname>
        (option 1) can override the selected
        <classname>ServerSocketFactory</classname> until
        <methodname>Connector.start()</methodname> is called.</para>
      </section>

      <section>
        <title>Socket factories</title>

        <para>For <classname>SocketFactory</classname>s, there are also ten
        options for programmatic configuration, and they are essentially the
        same as the previous ten. Note, however, that options 5 and 6 are
        reversed. This is because an
        <classname>ServerSocketFactoryMBean</classname>, if it exists, is
        given precedence over class names:</para>

        <orderedlist>
          <listitem>
            <para>Call
            <methodname>Connector.setSocketFactory()</methodname>.</para>
          </listitem>

          <listitem>
            <para>Get the <classname>ServerInvoker</classname> by calling
            <methodname>Connector.getServerInvoker()</methodname> and call
            <methodname>ServerInvoker.setSocketFactory()</methodname>.</para>
          </listitem>

          <listitem>
            <para>Put a constructed <classname>SocketFactory</classname> in a
            configuration map, using key
            <constant>Remoting.CUSTOM_SOCKET_FACTORY</constant>, and pass the
            map to one of the <classname>Connector</classname>
            constructors.</para>
          </listitem>

          <listitem>
            <para>Create an xml document with root element
            <code>&lt;config&gt;</code>, setting the
            <code>&lt;serverSocketFactory&gt;</code> attribute to the name of
            a <classname>ServerSocketFactoryMBean</classname> and pass the
            document to <methodname>Connector.setConfiguration()</methodname>.
            If the MBean has type
            <classname>SSLServerSocketFactoryServiceMBean</classname>, its
            configuration information will be gathered and used to construct a
            <classname>CustomSSLSocketFactory</classname>. <emphasis
            role="bold">Note.</emphasis> This method is guaranteed to work
            only for callback client invokers. For other, transport specific,
            socket factory uses, the transport may or may not use this
            information.</para>
          </listitem>

          <listitem>
            <para>Put the <classname>ObjectName</classname> of a
            <classname>ServerSocketFactoryMBean</classname> in a configuration
            map, using key
            <constant>ServerInvoker.SERVER_SOCKET_FACTORY</constant>, and pass
            the map to one of the <classname>Connector</classname>
            constructors. If the MBean has type
            <classname>SSLServerSocketFactoryServiceMBean</classname>, its
            configuration information will be gathered and used to construct a
            <classname>CustomSSLSocketFactory</classname>. <emphasis
            role="bold">Note.</emphasis> This method is guaranteed to work
            only for callback client invokers. For other, transport specific,
            socket factory uses, the transport may or may not use this
            information.</para>
          </listitem>

          <listitem>
            <para>Create an xml document with root element
            <code>&lt;config&gt;</code>, setting the
            <code>&lt;socketFactory&gt;</code> attribute to the class name of
            a <classname>SocketFactory</classname> and pass the document to
            <methodname>Connector.setConfiguration()</methodname>. For
            example: <programlisting>StringBuffer buf = new StringBuffer();
buf.append("&lt;?xml version=\"1.0\"?&gt;\n");
buf.append("&lt;config&gt;");
buf.append("   &lt;invoker transport=\"sslsocket\"&gt;");
buf.append("      &lt;attribute name=\"serverBindAddress\"&gt;" + getHostName() + "&lt;/attribute&gt;");
buf.append("      &lt;attribute name=\"serverBindPort\"&gt;" + freeport + "&lt;/attribute&gt;");
buf.append("      &lt;attribute name=\"socketFactory\"&gt;" + socketFactoryClassname + "&lt;/attribute&gt;");
buf.append("   &lt;/invoker&gt;");
buf.append("&lt;/config&gt;");

ByteArrayInputStream bais = new ByteArrayInputStream(buf.toString().getBytes());
Document xml = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(bais);
connector.setConfiguration(xml.getDocumentElement());</programlisting> The
            <classname>SocketFactory</classname> class must have a default
            constructor, which will be used to create a
            <classname>SocketFactory</classname>.</para>
          </listitem>

          <listitem>
            <para>Put the class name of a <classname>SocketFactory</classname>
            in a configuration map, using key
            <constant>Remoting.SOCKET_FACTORY_CLASS_NAME</constant>, and pass the
            map to one of the <classname>Connector</classname> constructors.
            The <classname>SocketFactory</classname> class must have a default
            constructor.</para>
          </listitem>

          <listitem>
            <para>Put a set of SSL parameters, using the keys in
            <classname>org.jboss.remoting.security.SSLSocketBuilder</classname>,
            in a configuration map and pass the map to one of the
            <classname>Connector</classname> constructors. These will be used
            by <classname>SSLSocketBuilder</classname> (see below) to create a
            <classname>CustomSSLSocketFactory</classname>.</para>
          </listitem>

          <listitem>
            <para>Configure an appropriate set of SSL system properties and
            use one of the SSL transports (https, sslrmi, or
            sslsocket). The properties will be used to create some kind of
            <classname>SSLSocketFactory</classname>, as determined by the
            transport.</para>
          </listitem>

          <listitem>
            <para>Use one of the non-SSL transports and do nothing. Ordinary
            <classname>Socket</classname>s will be used.</para>
          </listitem>
        </orderedlist>

        <para>Again, these are essentially in descending order of precedence.
        Options 1, 2, 3, 6, and 7 are illustrated in
        <classname>FactoryConfigSample</classname> and options 4, 5, 8, and 9
        are illustrated in <classname>FactoryConfigSSLSample</classname>, both
        of which are in package
        <classname>org.jboss.remoting.samples.config.factories</classname>.</para>

        <para><emphasis role="bold">Timing considerations.</emphasis> A new
        <classname>Client</classname>, with a client invoker, is created on
        the server side whenever a callback listener is registered by a call
        to <methodname>Client.addListener()</methodname>. If a
        <classname>SocketFactory</classname> is supplied by any of options 1
        to 5, it will be passed to the <classname>Client</classname>.
        Otherwise, any information from options 6 to 9 will be passed to the
        client invoker, which will create a
        <classname>SocketFactory</classname> according to the rules given
        below in the section on client side socket factory configuration. Once
        <methodname>Connector.create()</methodname> has been called,
        <methodname>ServerInvoker.setSocketFactory()</methodname>, may be
        called at any time to determine the
        <classname>SocketFactory</classname> used by the next callback client
        invoker.</para>
      </section>
    </section>

    <section>
      <title>Client side programmatic configuration</title>

      <para>On the client side it is possible to configure socket factories
      for client invokers and to configure server socket factories for
      callback server invokers. Configuration on the client side is largely
      the same as configuration on the server side, with the exception that no
      <classname>MBeanServer</classname> is assumed to be present, and the
      <classname>Client</classname> has no facilities for parsing xml
      documents.</para>

      <section>
        <title>Server socket factories.</title>

        <para>For <classname>ServerSocketFactory</classname>s in callback
        server invokers, there are eight options for programmatic
        configuration, which are identical to options 1-3, 5 and 7-10 on the
        server side (we don't assume the existence of an
        <classname>MBeanServer</classname> on the client side:</para>

        <orderedlist>
          <listitem>
            <para>Get the <classname>ServerInvoker</classname> by calling
            <methodname>Connector.getServerInvoker()</methodname> and call
            <methodname>ServerInvoker.setServerSocketFactory()</methodname>.</para>
          </listitem>

          <listitem>
            <para>Call
            <methodname>Connector.setServerSocketFactory()</methodname>.</para>
          </listitem>

          <listitem>
            <para>Put a constructed <classname>ServerSocketFactory</classname>
            in a configuration map, using key
            <constant>Remoting.CUSTOM_SERVER_SOCKET_FACTORY</constant>, and
            pass the map to one of the <classname>Connector</classname>
            constructors.</para>
          </listitem>

          <listitem>
            <para>Create an xml document with root element
            <code>&lt;config&gt;</code>, setting the
            <code>&lt;serverSocketFactory&gt;</code> attribute to the class
            name of a <classname>ServerSocketFactory</classname> and pass the
            document to <methodname>Connector.setConfiguration()</methodname>.
            For example: <programlisting>StringBuffer buf = new StringBuffer();
buf.append("&lt;?xml version=\"1.0\"?&gt;\n");
buf.append("&lt;config&gt;");
buf.append("   &lt;invoker transport=\"sslsocket\"&gt;");
buf.append("      &lt;attribute name=\"serverBindAddress\"&gt;" + getHostName() + "&lt;/attribute&gt;");
buf.append("      &lt;attribute name=\"serverBindPort\"&gt;" + freeport + "&lt;/attribute&gt;");
buf.append("      &lt;attribute name=\"serverSocketFactory\"&gt;" + serverSocketFactoryClassname + "&lt;/attribute&gt;");
buf.append("   &lt;/invoker&gt;");
buf.append("&lt;/config&gt;");

ByteArrayInputStream bais = new ByteArrayInputStream(buf.toString().getBytes());
Document xml = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(bais);
connector.setConfiguration(xml.getDocumentElement());</programlisting> The
            <classname>ServerSocketFactory</classname> class must have a
            default constructor, which will be used to create a
            <classname>ServerSocketFactory</classname>.</para>
          </listitem>

          <listitem>
            <para>Put the class name of a
            <classname>ServerSocketFactory</classname> in a configuration map,
            using key
            <constant>ServerInvoker.SERVER_SOCKET_FACTORY</constant>, and pass
            the map to one of the <classname>Connector</classname>
            constructors. The <classname>ServerSocketFactory</classname> class
            must have a default constructor, which will be used to create a
            <classname>ServerSocketFactory</classname>.</para>
          </listitem>

          <listitem>
            <para>Put a set of SSL parameters, using the keys in
            <classname>org.jboss.remoting.security.SSLSocketBuilder</classname>,
            in a configuration map and pass the map to one of the
            <classname>Connector</classname> constructors. These will be used
            by <classname>SSLSocketBuilder</classname> (see below) to create a
            <classname>CustomSSLServerSocketFactory</classname>.</para>
          </listitem>

          <listitem>
            <para>Configure an appropriate set of SSL system properties and
            use one of the SSL transports (https, sslrmi, or
            sslsocket). The properties will be used to create some kind of
            <classname>SSLServerSocketFactory</classname>, as determined by
            the transport.</para>
          </listitem>

          <listitem>
            <para>Use one of the non-SSL transports and do nothing. A default
            <classname>ServerSocketFactory</classname> will be
            constructed.</para>
          </listitem>
        </orderedlist>

        <para>These options are essentially in descending order of precedence.
        For example, if options 3 and 5, for example, are both used, the
        factory passed in options 3 will prevail. Options 1, 2, 3, 4, and 5
        are illustrated in <classname>FactoryConfigSample</classname> and
        options 6 and 7 are illustrated in
        <classname>FactoryConfigSSLSample</classname>, both of which are in
        package
        <classname>org.jboss.remoting.samples.config.factories</classname>.</para>

        <para><emphasis role="bold">Timing considerations.</emphasis> See the
        discussion in the section on the creation of server socket factories
        on the server side.</para>
      </section>

      <section>
        <title>Socket factories.</title>

        <para>For <classname>SocketFactory</classname>s in client invokers,
        there are seven options for programmatic configuration, and they are
        essentially the same as 1-3 and 5-8 in the previous section
        (<classname>Client</classname> has no facility for parsing xml
        documents:</para>

        <orderedlist>
          <listitem>
            <para>Get the <classname>ClientInvoker</classname> by calling
            <methodname>Client.getInvoker()</methodname> and call
            <methodname>ClientInvoker.setSocketFactory()</methodname>.</para>
          </listitem>

          <listitem>
            <para>Call
            <methodname>Client.setSocketFactory()</methodname>.</para>
          </listitem>

          <listitem>
            <para>Put a constructed <classname>SocketFactory</classname> in a
            configuration map, using key
            <constant>Remoting.CUSTOM_SOCKET_FACTORY</constant>, and pass the
            map to one of the <classname>Client</classname>
            constructors.</para>
          </listitem>

          <listitem>
            <para>Put the class name of a <classname>SocketFactory</classname>
            in a configuration map, using key
            <constant>Remoting.SOCKET_FACTORY_CLASS_NAME</constant>, and pass the
            map to one of the <classname>Client</classname> constructors. The
            <classname>SocketFactory</classname> class must have a default
            constructor, which will be used to create a
            <classname>SocketFactory</classname>.</para>
          </listitem>

          <listitem>
            <para>Put a set of SSL parameters, using the keys in
            <classname>org.jboss.remoting.security.SSLSocketBuilder</classname>,
            in a configuration map and pass the map to one of the
            <classname>Client</classname> constructors. These will be used by
            <classname>SSLSocketBuilder</classname> (see below) to create a
            <classname>CustomSSLSocketFactory</classname>.</para>
          </listitem>

          <listitem>
            <para>Configure an appropriate set of SSL system properties and
            use one of the SSL transports (https, sslrmi, or
            sslsocket). The properties will be used to create some kind of
            <classname>SSLSocketFactory</classname>, as determined by the
            transport.</para>
          </listitem>

          <listitem>
            <para>Use one of the non-SSL transports and do nothing. Ordinary
            <classname>Socket</classname>s will be used.</para>
          </listitem>
        </orderedlist>

        <para>Again, these are essentially in descending order of precedence.
        Options 1, 2, 3, and 4 are illustrated in
        <classname>FactoryConfigSample</classname> and options 5 and 6 are
        illustrated in <classname>FactoryConfigSSLSample</classname>, both of
        which are in package
        <classname>org.jboss.remoting.samples.config.factories</classname>.</para>

        <para><emphasis role="bold">Timing considerations.</emphasis> A
        <classname>SocketFactory</classname> is created in the constructor for
        <classname>RemoteClientInvoker</classname>, the ancestor of all
        current remote client invokers (that is, all client invokers except
        <classname>LocalClientInvoker</classname>, which can make a call by
        reference on a server invoker in the same JVM), but it is currently
        used only by SSL transports, for which the timing considerations
        vary.</para>

        <orderedlist>
          <listitem>
            <para><emphasis role="bold">https: </emphasis>
            <classname>HTTPSClientInvoker</classname> sets the socket factory
            on its <classname>HttpsURLConnection</classname> each time
            <methodname>Client.invoke()</methodname> is called. Option 1 may
            be used to reset the <classname>SocketFactory</classname> for
            future invocations at any time.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">sslrmi: </emphasis> A
            <classname>SocketFactory</classname> is either created or
            configured for future creation during
            <methodname>Client.create()</methodname>. No further configuration
            is possible.</para>
          </listitem>

          <listitem>
            <para><emphasis role="bold">sslsocket: </emphasis>
            <classname>SSLSocketClientInvoker</classname> uses the current
            <classname>SocketFactory</classname> to create a new socket
            whenever it runs out of available pooled connections. Option 1 may
            be used to reset the <classname>SocketFactory</classname> for
            future connections at any time.</para>
          </listitem>
        </orderedlist>
      </section>
    </section>

    <section>
      <title>Server side configuration in the JBoss Application Server</title>

      <para>Everything in the previous two sections applies to configuring
      socket and server socket factories in any environment, including inside
      the JBoss Application Server (JBossAS), but JBossAS adds some new
      options. In particular, the <classname>SARDeployer</classname> (see
      <emphasis>The JBoss 4 Application Server Guide</emphasis> on the
      labs.jboss.org web site) can read information from a
      <code>*-service.xml</code> file, as discussed above in the section
      "General Connector and Invoker configuration," and use it to configure
      MBeans such as <classname>Connector</classname>s.</para>

      <para>An example of a service xml that covers all the different
      transport and service configurations can be found within the
      example-service.xml file under the etc directory of the JBoss Remoting
      distribution.</para>

      <para>The server socket factory to be used by a server invoker can be
      set via configuration within the service xml. To do this, the
      serverSocketFactory attribute will need to be set as a sub-element of
      the invoker element (this cannot be done if just specifying the invoker
      configuration using the InvokerLocator attribute). The attribute value
      must be either</para>

      <orderedlist>
        <listitem>
          <para>the JMX ObjectName of an MBean that implements the
          <code>org.jboss.remoting.security.ServerSocketFactoryMBean</code>
          interface, or</para>
        </listitem>

        <listitem>
          <para>the class name of a <classname>ServerSocketFactory</classname>
          with a default constructor.</para>
        </listitem>
      </orderedlist>

      <para>An example of the first case would be:</para>

      <programlisting>&lt;mbean code="org.jboss.remoting.transport.Connector"
       name="jboss.remoting:service=Connector,transport=Socket"
       display-name="Socket transport Connector"&gt;

   &lt;attribute name="Configuration"&gt;
      &lt;config&gt;
         &lt;invoker transport="sslsocket"&gt;
            &lt;attribute name="serverSocketFactory"&gt;
               jboss.remoting:service=ServerSocketFactory,type=SSL
            &lt;/attribute&gt;
            &lt;attribute name="numAcceptThreads"&gt;1&lt;/attribute&gt;
            ...</programlisting>

      <para>The <code>serverSocketFactory</code> attribute is processed as
      follows:</para>

      <orderedlist>
        <listitem>
          <para>Take its String value, create an
          <classname>ObjectName</classname> from it, and look up an MBean with
          that name from the <classname>MBeanServer</classname> that the
          invoker has been registered with (by way of the
          <classname>Connector</classname>). If an MBean with that name is
          found, create a proxy to it of type
          <code>org.jboss.remoting.security.ServerSocketFactoryMBean</code>.
          (Technically, a user could set the <code>serverSocketFactory</code>
          property with the locator url, but the preferred method is to use
          the explicit configuration via the invoker element's attribute, as
          discussed above.)</para>
        </listitem>

        <listitem>
          <para>If no MBean is found with a matching
          <classname>ObjectName</classname>, treat the
          <code>serverSocketFactory</code> attribute as a class name and try
          to create an instance using the default constructor.</para>
        </listitem>
      </orderedlist>

      <para>The JBossRemoting project provides an implementation of the
      ServerSocketFactoryMBean that can be used and should provide most of the
      customization features that would be needed. More on this implementation
      later.</para>

      <para>Note that these two options correspond exactly to options 4 and 5
      in section <xref linkend="section-ssf-serverside" /> (on the server
      side), which is how these two new options are implemented.</para>

      <para><emphasis role="bold">Timing considerations.</emphasis> If a
      <classname>Connector</classname> is accessed by way of the
      <classname>MBeanServer</classname>, then most of the options for
      configuring the server socket factory discussed in <xref
      linkend="section-ssf-serverside" /> are irrelevant since
      <classname>ConnectorMBean</classname> does not expose methods for using
      them. However, when a <classname>Connector</classname> that is
      registered with an <classname>MBeanServer</classname> creates a server
      invoker during a call to <methodname>Connector.create()</methodname>, it
      also registers the server invoker with the same
      <classname>MBeanServer</classname>, which means that the server invoker
      is accessible by way of its <classname>ObjectName</classname>, which has
      the form</para>

      <programlisting>jboss.remoting:service=invoker,transport=socket,host=www.jboss.com,port=8765</programlisting>

      <para>for example, followed by additional parameter=value pairs. (See
      the jmx-console for a running instance of JBossAS at
      http://localhost:8080/jmx-console/ to see examples of server invoker
      <classname>ObjectName</classname>s.) Now, if another MBean is configured
      in a <code>*-service.xml</code> file to be dependent on the server
      invoker MBean, e.g.</para>

      <programlisting>&lt;mbean code="org.jboss.BlueMonkey" name="jboss.remoting:bluemonkey,name=diamond"&gt;
   &lt;depends optional-attribute-name="serverInvoker"&gt;
      jboss.remoting:service=invoker,transport=socket,host=www.jboss.com,port=8765
   &lt;/depends&gt;
&lt;/mbean&gt;</programlisting>

      <para>then <methodname>org.jboss.BlueMonkey.create()</methodname> will
      have access to the designated server invoker after the invoker has been
      created but before it has been started, which means that
      <methodname>ServerInvoker.setServerSocketFactory()</methodname> will be
      effective. (See the <emphasis>The JBoss 4 Application Server
      Guide</emphasis>, Chapter 2, for more information about the life cycle
      of JBoss MBeans.)</para>
    </section>
    
    <section >
      <title>Client side configuration from the JBoss Application Server</title>
      
      <para>As described in sections <xref linkend="section-declarative-configuration-mbeans"/>
      and <xref linkend="section-declarative-configuration-pojos"/>,
      the declarative xml files used by the Application Server can be used to configure the 
      client by way of the parameters included in the <classname>InvokerLocator</classname>.
      However, a peculiarity in the way socket factories are created on the client 
      restricts the parameters taken into consideration to those passed in the 
      configuration map passed to the <classname>org.jboss.remoting.Client</classname>
      constructor.  The following two parameters, introduced in releases 2.4.0.SP1 and
      2.5.2, respectively, eliminate that restriction.</para>
      
      <para><emphasis role="bold">org.jboss.remoting.Remoting.SOCKET_FACTORY_NAME</emphasis> (actual value
      is 'socketFactory') - key for giving the name of the socket factory class to be used
      by clients.</para>

      <para><emphasis role="bold">org.jboss.remoting.Remoting.USE_ALL_SOCKET_FACTORY_PARAMS</emphasis> (actual value
      is 'useAllSocketFactoryParams') - key for indicating that all socket factory parameters
      in the <classname>InvokerLocator</classname> should be used by clients.</para>
      
      <para>Note that the parameter <code>org.jboss.remoting.Remoting.CONFIG_OVERRIDES_LOCATOR</code>
      (actual value "configOverridesLocator"), described in section
      <xref linkend="section-org-jboss-remoting-Remoting"/>, is also relevant.</para>
    </section>
    
    <section>
      <title>Socket creation listeners</title>
      
      <para>
        Every Remoting transport uses <classname>Socket</classname>s, but the
        creation and management of the <classname>Socket</classname>s is
        generally inaccessible from the application code. Remoting has a hook
        that can provide access to <classname>Socket</classname>s, in the form
        of a listener interface in the
        <code>org.jboss.remoting.socketfactory</code> package:
      </para>
      
      <programlisting>public interface SocketCreationListener
{
   /**
    * Called when a socket has been created.
    * 
    * @param socket socket that has been created
    * @param source SocketFactory or ServerSocket that created the socket
    * @throws IOException
    */
   void socketCreated(Socket socket, Object source) throws IOException;
}</programlisting>
      
      <para>
        Socket creation listeners can be registered to be informed every time a
       socket is created by a <classname>SocketFactory</classname> or
       <classname>ServerSocket</classname>. The mechanisms for registering
       listeners are the usual ones, e.g., by putting them in configuration
       maps passed to client and server invokers. (See Section <xref
       linkend="section-configuration"/> for a general discussion of parameter
       configuration in Remoting.) In any case they should be associated with
       one of the following keys from
       <classname>org.jboss.remoting.Remoting</classname>:
      </para>
      
      <programlisting>/**
 * Key for the configuration map passed to a Client or Connector to indicate
 * a socket creation listener for sockets created by a SocketFactory.
 */
public static final String SOCKET_CREATION_CLIENT_LISTENER = "socketCreationClientListener";
      
/**
 * Key for the configuration map passed to a Client or Connector to indicate
 * a socket creation listener for sockets created by a ServerSocket.
 */
public static final String SOCKET_CREATION_SERVER_LISTENER = "socketCreationServerListener";</programlisting>
      
      <para>
        The value associated with either of these keys can be an actual object,
        or, to facilitate configuration by <classname>InvokerLocator</classname>
        or xml, it can be the name of a class that implements
        <classname>SocketCreationListener</classname> and has a default
        constructor 
      </para>
      
      <para>
        Note that client and server invokers always use the respective keys
        SOCKET_CREATION_CLIENT_LISTENER and SOCKET_CREATION_SERVER_LISTENER,
        whether they are on the client side or server side.  For example, a
        callback client invoker would be configured by putting a listener with
        the key SOCKET_CREATION_CLIENT_LISTENER in the configuration map passed
        to the server side <classname>Connector</classname>, which will find its
        way to the callback client invoker when a callback handler is registered.
      </para>

      <para>
        The creation listener facility currently is supported by the following
        transports: bisocket, sslbisocket, https, rmi,
        sslrmi, socket, and sslsocket. It is not supported by http because
        <classname>HttpURLConnection</classname> does not expose its socket
        factory (though <classname>HttpsURLConnection</classname> does). It is
        not supported by the servlet transport because invocations with the
        servlet transport go through a servlet container, which is outside the
        scope of Remoting. 
      </para>
    </section>

    <section>
      <title>SSL transports</title>

      <para>There are now four transports that support SSL: https,
      sslrmi, and sslsocket (plus sslservlet, which is not
      relevant here). All of the preceding discussion applies to each of
      these, and, moreover, they are all extensions of their non-ssl
      counterparts, so only some ssl specific information will be added
      here.</para>

      <bridgehead>https</bridgehead>

      <para>Configuration of the https transport is a bit different from that
      of the other transports since the implementation is based off the Tomcat
      connectors. One difference is that, in order to use SSL connections, the
      <code>SSLImplementation</code> attribute must be set and must always
      have the value
      <classname>org.jboss.remoting.transport.coyote.ssl.RemotingSSLImplementation</classname>.
      The <code>SSLImplementation</code> is used by the Tomcat connector to
      create <classname>ServerSocketFactory</classname>s, and
      <classname>RemotingSSLImplementation</classname> presents Tomcat with
      the <classname>ServerSocketFactory</classname> configured according to
      the options described above.</para>

      <!--
         <para>Next is defining the SSL implementation and server socket factory
         to be used. The SSL implementation to be used can be set via the
         'SSLImplementation' attribute and should always have a value of
         <code>org.jboss.remoting.transport.coyote.ssl.RemotingSSLImplementation</code>.
         The server socket factory to be used should be set via the
         'serverSocketFactory' attribute and should always be the
         javax.management.ObjectName value for an implementation of the
         <code>org.jboss.remoting.security.ServerSocketFactoryMBean</code>
         interface, which should already be registered with the MBeanServer and
         running (more details on this in a minute).</para>-->

      <para>An example of setting up https via service.xml configuration would
      be:</para>

      <programlisting>&lt;mbean code="org.jboss.remoting.transport.Connector"
       name="jboss.remoting:service=Connector,transport=HTTPS"
       display-name="HTTPS transport Connector"&gt;

   &lt;attribute name="Configuration"&gt;
      &lt;config&gt;
         &lt;invoker transport="https"&gt;
            &lt;attribute name="serverSocketFactory"&gt;
               jboss.remoting:service=ServerSocketFactory,type=SSL
            &lt;/attribute&gt;
            &lt;attribute name="SSLImplementation"&gt;
               org.jboss.remoting.transport.coyote.ssl.RemotingSSLImplementation
            &lt;/attribute&gt;
            &lt;attribute name="serverBindAddress"&gt;${jboss.bind.address}&lt;/attribute&gt;
            &lt;attribute name="serverBindPort"&gt;6669&lt;/attribute&gt;
         &lt;/invoker&gt;
         &lt;handlers&gt;
            &lt;handler subsystem="mock"&gt;
               org.jboss.test.remoting.transport.mock.MockServerInvocationHandler
            &lt;/handler&gt;
         &lt;/handlers&gt;
      &lt;/config&gt;
   &lt;/attribute&gt;
   &lt;!-- This depends is included because need to make sure
        this mbean is running before configure invoker. --&gt;
   &lt;depends&gt;jboss.remoting:service=ServerSocketFactory,type=SSL&lt;/depends&gt;
&lt;/mbean&gt;</programlisting>

      <para>See section <xref
      linkend="section-SSLServerSocketFactoryService" /> below for a
      discussion of the "jboss.remoting:service=ServerSocketFactory,type=SSL"
      MBean that appears in this configuration element.</para>

      <para>Note that the configuration for SSL support only works when using
      the java based http processor and not with the APR based transport. See
      section <xref linkend="section-http-invoker" /> for more information on
      using the APR based transport.</para>

      <bridgehead id="subsection-sslrmi"
      xreflabel="sslrmi">sslrmi</bridgehead>

      <para>The extra twist in the sslrmi invoker is that the server invoker
      creates the (client) socket factory and packages it with its own stub,
      from which it follows that the socket factory must be serializable. If
      the sslrmi server invoker is allowed to create an
      <classname>SSLSocketFactory</classname> from SSL parameters, it will
      take care to create a serializable socket factory. In particular, the
      server invoker creates a copy of
      <classname>org.jboss.remoting.transport.rmi.ssl.SerializableSSLClientSocketFactory</classname>,
      which is essentially just a holder for the configuration map passed to
      the server invoker, with any parameters removed which concern trust
      store and key store configuration. On the client side, when an sslrmi
      client invoker is created, it stores its own configuration map in a
      static variable which the transferred
      <classname>SerializableSSLClientSocketFactory</classname> can retrieve
      and merge with the configuration information it brought with it from the
      server. In particular, if a socket factory is explicitly passed to the
      client invoker, then
      <classname>SerializableSSLClientSocketFactory</classname> will use it.
      If not, then <classname>SerializableSSLClientSocketFactory</classname>
      will use any key store and trust store information passed to the client
      to create and configure a socket factory.</para>

      <para><emphasis role="bold">Note.</emphasis> If instead of using
      <classname>SerializableSSLClientSocketFactory</classname>, a socket
      factory is passed in to the server invoker by one of the methods
      discussed above, then the user is responsible for supplying a
      serializable socket factory.</para>

      <bridgehead>sslsocket</bridgehead>

      <para>In addition to the various configuration options discussed above,
      the sslsocket transport exposes the</para>

      <programlisting>public void setServerSocketFactory(ServerSocketFactory serverSocketFactory)</programlisting>

      <para>method as a JMX operation.</para>

      <para>Also, the sslsocket server invoker inherits from the socket server
      invoker a method with signature</para>

      <programlisting>public void setNewServerSocketFactory(ServerSocketFactory serverSocketFactory)</programlisting>

      <para>which supports dynamic replacement of server socket factories. The
      principal motivation for this facility is to be able to swap in a new
      <classname>SSLServerSocketFactory</classname> configured with an updated
      keystore.</para>
    </section>

    <section>
      <title>SSLSocketBuilder</title>

      <para>Throughout this section reference has been made to SSL socket
      factory and server socket factory configuration parameters. This
      subsection will introduce these parameters in the context of configuring
      <classname>org.jboss.remoting.security.SSLSocketBuilder</classname>,
      Remoting's flexible, highly customizable master factory for creating
      socket and server socket factories. It can be used programmatically on
      both the client and server side, and it is also a service MBean, so it
      can be configured and started from within a service xml in a JBossAS
      environment.</para>

      <para>Once a <classname>SSLSocketBuilder</classname> has been
      constructed and configured, a call to its method
      <methodname>createSSLServerSocketFactory()</methodname> will return a
      custom instance of a <classname>SSLServerSocketFactory</classname>, and
      a call to <methodname>createSSLSocketFactory()</methodname> will return
      a custom instance of <classname>SSLSocketFactory</classname>.</para>

      <para>There are two modes in which the
      <classname>SSLSocketBuilder</classname> can be run. The first is the
      default mode where all that is needed is to declare the
      <classname>SSLSocketBuilder</classname> and set the system properties
      <code>javax.net.ssl.keyStore</code> and
      <code>javax.net.ssl.keyStorePassword</code>. This will use the JVM
      vendor's default configuration for creating the SSL server socket
      factory.</para>

      <para>In order to customize any of the SSL properties, the first
      requirement is that the default mode is turned off. This is <emphasis
      role="bold">IMPORTANT</emphasis> because otherwise, if the default mode
      is not explicitly turned off, all other settings will be IGNORED, even
      if they are explicitly set. To turn off the default mode via service xml
      configuration, set the <code>UseSSLServerSocketFactory</code> attribute
      to false. This can also be done programmatically by calling the
      <code>setUseSSLServerSocketFactory()</code> and passing false as the
      parameter value.</para>

      <para>There are two ways to configure a
      <classname>SSLSocketBuilder</classname></para>

      <orderedlist>
        <listitem>
          <para>set its bean attributes, either programmatically or by xml
          configuration, or</para>
        </listitem>

        <listitem>
          <para>pass to a <classname>SSLSocketBuilder</classname> constructor
          a configuration map with keys defined in the
          <classname>SSLSocketBuilder</classname> class.</para>
        </listitem>
      </orderedlist>

      <para>The configuration properties for
      <classname>SSLSocketBuilder</classname>are as follows. Note that in the
      "key name" column, the name in capital letters (e.g.,
      REMOTING_CLIENT_AUTH_MODE) is a handy constant in the
      <classname>SSLSocketBuilder</classname> class with the value given in
      parentheses (e.g. "org.jboss.remoting.clientAuthMode"). It is the latter
      that should be used for declarative configuration in, for example, MBean
      descriptors.</para>

      <table frame="all" id="SSLSocketBuilderTable" xreflabel="Table 1">
        <title><classname>SSLSocketBuilder</classname> configuration
        parameters.</title>

        <tgroup cols="5">
          <colspec colname="c1" colnum="1" />

          <colspec colname="c2" colnum="2" />

          <colspec align="center" colname="c3" colnum="3" />

          <colspec align="center" colname="c4" colnum="4" />

          <colspec colname="c5" colnum="5" />

          <thead>
            <row>
              <entry><para>attribute</para></entry>

              <entry><para>key name</para></entry>

              <entry><para>type</para></entry>

              <entry><para>default</para></entry>

              <entry><para>description</para></entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry><para>ClientAuthMode</para></entry>

              <entry><para>REMOTING_CLIENT_AUTH_MODE ("org.jboss.remoting.clientAuthMode")</para></entry>

              <entry><para>String</para></entry>

              <entry><para>need</para></entry>

              <entry><para>Determines if sockets need or want client
              authentication. This configuration option is only useful for
              sockets in the server mode. Value may be "none", "want", or
              "need".</para></entry>
            </row>

            <row>
              <entry><para>KeyAlias</para></entry>

              <entry><para>REMOTING_KEY_ALIAS ("org.jboss.remoting.keyAlias")</para></entry>
              
              <entry><para>String</para></entry>

              <entry><para></para></entry>

              <entry><para>The preferred identity in key store to be used by
              key managers</para></entry>
            </row>

            <row>
              <entry><para>KeyPassword</para></entry>

              <entry><para>REMOTING_KEY_PASSWORD ("org.jboss.remoting.keyPassword")</para></entry>

              <entry><para>String</para></entry>

              <entry><para></para></entry>

              <entry><para>Sets the password to use for the keys within the
              key store. This only needs to be set if
              <methodname>setUseSSLServerSocketFactory()</methodname> is set
              to false (otherwise will be ignored). If this value is not set,
              but the key store password is, it will use that value for the
              key password.</para></entry>
            </row>

            <row>
              <entry><para>KeyStoreAlgorithm</para></entry>

              <entry><para>REMOTING_KEY_STORE_ALGORITHM ("org.jboss.remoting.keyStoreAlgorithm")</para></entry>

              <entry><para>String</para></entry>

              <entry><para>SunX509</para></entry>

              <entry><para>The algorithm for the key manager
              factory.</para></entry>
            </row>

            <row>
              <entry><para>KeyStorePassword</para></entry>

              <entry><para>REMOTING_KEY_STORE_PASSWORD ("org.jboss.remoting.keyStorePassword")</para></entry>

              <entry><para>String</para></entry>

              <entry><para></para></entry>

              <entry><para>The password to use for the key store. This only
              needs to be set if
              <methodname>setUseSSLServerSocketFactory()</methodname> is set
              to false (otherwise will be ignored). The value passed will also
              be used for the key password if the latter attribute is not
              explicitly set.</para></entry>
            </row>

            <row>
              <entry><para>KeyStoreType</para></entry>

              <entry><para>REMOTING_KEY_STORE_TYPE ("org.jboss.remoting.keyStoreType")</para></entry>

              <entry><para>String</para></entry>

              <entry><para>JKS</para></entry>

              <entry><para>The type to be used for the key store. Some
              acceptable values are JKS (Java Keystore - Sun's keystore
              format), JCEKS (Java Cryptography Extension keystore - More
              secure version of JKS), and PKCS12 (Public-Key Cryptography
              Standards #12 keystore - RSA's Personal Information Exchange
              Syntax Standard). These are not case sensitive.</para></entry>
            </row>

            <row>
              <entry><para>KeyStoreURL</para></entry>

              <entry><para>REMOTING_KEY_STORE_FILE_PATH ("org.jboss.remoting.keyStore")</para></entry>

              <entry><para>String</para></entry>

              <entry><para></para></entry>

              <entry><para>Property used to define where
              <classname>SSLSocketBuilder</classname> will look for the
              keystore file. This can be relative to the thread's classloader
              or can be an absolute path on the file system or can be a
              URL.  It can also be set to "NONE", in which case the keystore
              will be initialized but not populated from a file.  This feature
              might be useful in the case of a PKCS#11 smart card.
              </para></entry>
            </row>

            <row>
              <entry><para>Provider</para></entry>

              <entry><para>none</para></entry>

              <entry><para>java.security.Provider</para></entry>

              <entry><para></para></entry>

              <entry><para>Java Security API implementation to
              use.</para></entry>
            </row>

            <row>
              <entry><para>ProviderName</para></entry>

              <entry><para>REMOTING_SSL_PROVIDER_NAME ("org.jboss.remoting.sslProviderName")</para></entry>

              <entry><para>String</para></entry>

              <entry><para></para></entry>

              <entry><para>Name of Java Security API implementation to use.
              </para></entry>
            </row>

            <row>
              <entry><para>SecureRandom</para></entry>

              <entry><para>none</para></entry>

              <entry><para>java.security.SecureRandom</para></entry>

              <entry><para><code>new SecureRandom()</code></para></entry>

              <entry><para>Random number generator to use.</para></entry>
            </row>

            <row>
              <entry><para>SecureSocketProtocol</para></entry>

              <entry><para>REMOTING_SSL_PROTOCOL ("org.jboss.remoting.sslProtocol")</para></entry>

              <entry><para>String</para></entry>

              <entry><para>TLS</para></entry>

              <entry><para> The protocol for the
              <classname>SSLContext</classname>. Some acceptable values are
              TLS, SSL, and SSLv3</para></entry>
            </row>

            <row>
              <entry><para>ServerAuthMode</para></entry>

              <entry><para>REMOTING_SERVER_AUTH_MODE ("org.jboss.remoting.serverAuthMode")</para></entry>

              <entry><para>boolean/String</para></entry>

              <entry><para>true</para></entry>

              <entry><para>Determines if a client should attempt to
              authenticate a server certificate as one it
              trusts.</para></entry>
            </row>

            <row>
              <entry><para>ServerSocketUseClientMode</para></entry>

              <entry><para>REMOTING_SERVER_SOCKET_USE_CLIENT_MODE ("org.jboss.remoting.serversocket.useClientMode")</para></entry>

              <entry><para>boolean/String</para></entry>

              <entry><para>false</para></entry>

              <entry><para>Determines if the server sockets will be in client
              or server mode.</para></entry>
            </row>

            <row>
              <entry><para>SocketUseClientMode</para></entry>

              <entry><para>REMOTING_SOCKET_USE_CLIENT_MODE ("org.jboss.remoting.socket.useClientMode")</para></entry>

              <entry><para>boolean/String</para></entry>

              <entry><para>true</para></entry>

              <entry><para>Determines if the sockets will be in client or
              server mode.</para></entry>
            </row>

            <row>
              <entry><para>TrustStoreAlgorithm</para></entry>

              <entry><para>REMOTING_TRUST_STORE_ALGORITHM ("org.jboss.remoting.trustStoreAlgorithm")</para></entry>

              <entry><para>String</para></entry>

              <entry><para>value of <code>KeyStoreAlgorithm</code>, or SunX509
              if <code>KeyStoreAlgorithm</code> is not set</para></entry>

              <entry><para>trust store key management algorithm</para></entry>
            </row>

            <row>
              <entry><para>TrustStorePassword</para></entry>

              <entry><para>REMOTING_TRUST_STORE_PASSWORD ("org.jboss.remoting.trustStorePassword")</para></entry>

              <entry><para>String</para></entry>

              <entry><para></para></entry>

              <entry><para>trust store password</para></entry>
            </row>

            <row>
              <entry><para>TrustStoreType</para></entry>

              <entry><para>REMOTING_TRUST_STORE_TYPE ("org.jboss.remoting.trustStoreType")</para></entry>

              <entry><para>String</para></entry>

              <entry><para>value of <code>KeyStoreType</code>, or JKS if
              <code>KeyStoreType</code> is not set</para></entry>

              <entry><para>type of trust store</para></entry>
            </row>

            <row>
              <entry><para>TrustStoreURL</para></entry>

              <entry><para>REMOTING_TRUST_STORE_FILE_PATH ("org.jboss.remoting.trustStore")</para></entry>

              <entry><para>String</para></entry>

              <entry><para></para></entry>

              <entry><para>location of trust store. It can also be set to "NONE", in which case the truststore
              will be initialized but not populated from a file.  This feature
              might be useful in the case of a PKCS#11 smart card.</para></entry>
            </row>

            <row>
              <entry><para>UseSSLServerSocketFactory</para></entry>

              <entry><para>none</para></entry>

              <entry><para>boolean</para></entry>

              <entry><para>true</para></entry>

              <entry><para>Determines if default
              <classname>SSLServerSocketFactory</classname> should be
              created.</para></entry>
            </row>

            <row>
              <entry><para>UseSSLSocketFactory</para></entry>

              <entry><para>none</para></entry>

              <entry><para>boolean</para></entry>

              <entry><para>true</para></entry>

              <entry><para>Determines if default
              <classname>SSLSocketFactory</classname> should be
              created.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para><emphasis role="bold">Note.</emphasis> If any of the attributes
      <code>KeyStoreURL</code>, <code>KeyStorePassword</code>,
      <code>KeyStoreType</code>, <code>TrustStoreURL</code>,
      <code>TrustStorePassword</code>, or <code>TrustStoreType</code> are left
      unconfigured, <classname>SSLSocketBuilder</classname> will also examine
      the corresponding standard SSL system properties
      "javax.net.ssl.keyStore", "javax.net.ssl.keyStorePassword",
      "javax.net.ssl.keyStoreType", "javax.net.ssl.trustStore",
      "javax.net.ssl.trustStorePassword", "javax.net.ssl.trustStoreType". In
      the cases of <code>KeyStoreType</code> and <code>TrustStoreType</code>,
      <classname>SSLSocketBuilder</classname> will then go on to use default
      values after checking the system properties.</para>

      <para>The following is an example of configuring a
      <classname>SSLSocketBuilder</classname> and using it to create a custom
      <classname>SSLSocketFactory</classname>:</para>

      <programlisting>protected SSLSocketFactory getSocketFactory() throws Exception
{
   HashMap config = new HashMap();
   config.put(SSLSocketBuilder.REMOTING_KEY_STORE_TYPE, "JKS");
   String keyStoreFilePath = getKeystoreFilePath();
   config.put(SSLSocketBuilder.REMOTING_KEY_STORE_FILE_PATH, keyStoreFilePath);
   config.put(SSLSocketBuilder.REMOTING_KEY_STORE_PASSWORD, "unit-tests-server");
   config.put(SSLSocketBuilder.REMOTING_SSL_PROTOCOL, "SSL");
   SSLSocketBuilder builder = new SSLSocketBuilder(config);
   builder.setUseSSLSocketFactory(false);
   return builder.createSSLSocketFactory();
}</programlisting>

      <para>More examples of configuring
      <classname>SSLSocketBuilder</classname> can be found in the class
      <classname>FactoryConfigSSLSample</classname> in the package
      <code>org.jboss.remoting.samples.config.factories</code>.</para>

      <para>The following is an example of configuring
      <classname>SSLSocketBuilder</classname> in a *-service.xml file:</para>

      <programlisting>&lt;!-- This service is used to build the SSL Server socket factory --&gt;
&lt;!-- This will be where all the store/trust information will be set. --&gt;
&lt;!-- If do not need to make any custom configurations, no extra attributes --&gt;
&lt;!-- need to be set for the SSLSocketBuilder and just need to set the --&gt;
&lt;!-- javax.net.ssl.keyStore and javax.net.ssl.keyStorePassword system properties. --&gt;
&lt;!-- This can be done by just adding something like the following to the run --&gt;
&lt;!-- script for JBoss --&gt;
&lt;!-- (this one is for run.bat): --&gt;
&lt;!-- set JAVA_OPTS=-Djavax.net.ssl.keyStore=.keystore --&gt;
&lt;!-- -Djavax.net.ssl.keyStorePassword=opensource %JAVA_OPTS% --&gt;
&lt;!-- Otherwise, if want to customize the attributes for SSLSocketBuilder, --&gt;
&lt;!-- will need to uncomment them below. --&gt;
&lt;mbean code="org.jboss.remoting.security.SSLSocketBuilder"
       name="jboss.remoting:service=SocketBuilder,type=SSL"
       display-name="SSL Server Socket Factory Builder"&gt;
   &lt;!-- IMPORTANT - If making ANY customizations, this MUST be set to false. --&gt;
   &lt;!-- Otherwise, will used default settings and the following attributes will be ignored. --&gt;
   &lt;attribute name="UseSSLServerSocketFactory"&gt;false&lt;/attribute&gt;
   &lt;!-- This is the url string to the key store to use --&gt;
   &lt;attribute name="KeyStoreURL"&gt;.keystore&lt;/attribute&gt;
   &lt;!-- The password for the key store --&gt;
   &lt;attribute name="KeyStorePassword"&gt;opensource&lt;/attribute&gt;
   &lt;!-- The password for the keys (will use KeystorePassword if this is not set explicitly. --&gt;
   &lt;attribute name="KeyPassword"&gt;opensource&lt;/attribute&gt;
   &lt;!-- The protocol for the SSLContext. Default is TLS. --&gt;
   &lt;attribute name="SecureSocketProtocol"&gt;TLS&lt;/attribute&gt;
   &lt;!-- The algorithm for the key manager factory. Default is SunX509. --&gt;
   &lt;attribute name="KeyManagementAlgorithm"&gt;SunX509&lt;/attribute&gt;
   &lt;!-- The type to be used for the key store. --&gt;
   &lt;!-- Defaults to JKS. Some acceptable values are JKS (Java Keystore - Sun's keystore format), --&gt;
   &lt;!-- JCEKS (Java Cryptography Extension keystore - More secure version of JKS), and --&gt;
   &lt;!-- PKCS12 (Public-Key Cryptography Standards #12 keystore - RSA's Personal Information Exchange Syntax Standard). --&gt;
   &lt;!-- These are not case sensitive. --&gt;
   &lt;attribute name="KeyStoreType"&gt;JKS&lt;/attribute&gt;
&lt;/mbean&gt;</programlisting>

      <para>It is also possible to set the default socket factory to be used
      when not using customized settings (meaning UseSSLSocketFactory property
      value is true, which is the default). This can be done by setting system
      property of org.jboss.remoting.defaultSocketFactory to the fully
      qualified class name of the javax.net.SocketFactory implementation to
      use. Will then call the getDefault() method on that implementation to
      get the SocketFactory instance to use.</para>
    </section>

    <section id="section-SSLServerSocketFactoryService"
             xreflabel="SSLServerSocketFactoryService">
      <title>SSLServerSocketFactoryService</title>

      <para>Although any server socket factory can be set for the various
      transports, there is a customizable server socket factory service
      provided within JBossRemoting that supports SSL. This is the
      <code>org.jboss.remoting.security.SSLServerSocketFactoryService</code>
      class. The <code>SSLServerSocketFactoryService</code> class extends the
      <code>javax.net.ServerSocketFactory</code> class and also implements the
      <code>SSLServerSocketFactoryServiceMBean</code> interface (so that it
      can be set using the <code>socketServerFactory</code> attribute
      described previously). Other than providing the proper interfaces, this
      class is a simple wrapper around the
      <code>org.jboss.remoting.security.SSLSocketBuilder</code> class.</para>

      <para>The following is an example of configuring
      <classname>SSLServerSocketFactoryService</classname> in a *-service.xml
      file. Note that it depends on the
      <classname>SSLSocketBuilder</classname> MBean defined in the xml
      fragment above:</para>

      <programlisting>&lt;!-- This service provides the exact same API as the ServerSocketFactory, so --&gt;
&lt;!-- can be set as an attribute of that type on any MBean requiring an ServerSocketFactory. --&gt;
&lt;mbean code="org.jboss.remoting.security.SSLServerSocketFactoryService"
       name="jboss.remoting:service=ServerSocketFactory,type=SSL"
       display-name="SSL Server Socket Factory"&gt;
   &lt;depends optional-attribute-name="SSLSocketBuilder"
            proxy-type="attribute"&gt;jboss.remoting:service=SocketBuilder,type=SSL&lt;/depends&gt;
&lt;/mbean&gt;</programlisting>
    </section>

    <section>
      <title>General Security How To</title>

      <para>Since we are talking about keystores and truststores, this section
      will quickly go over how to quickly generate a test keystore and
      truststore for testing. This is not intended to be a full security
      overview, just an example of how I originally created mine for
      testing.</para>

      <para>To get started, will need to create key store and trust
      store.</para>

      <para>Generating key entry into keystore:</para>

      <programlisting>C:\tmp\ssl&gt;keytool -genkey -alias remoting -keyalg RSA
Enter keystore password: opensource
What is your first and last name?
[Unknown]: Tom Elrod
What is the name of your organizational unit?
[Unknown]: Development
What is the name of your organization?
[Unknown]: JBoss Inc
What is the name of your City or Locality?
[Unknown]: Atlanta
What is the name of your State or Province?
[Unknown]: GA
What is the two-letter country code for this unit?
[Unknown]: US
Is CN=Tom Elrod, OU=Development, O=JBoss Inc, L=Atlanta, ST=GA, C=US correct?
[no]: yes

Enter key password for &lt;remoting&gt;
(RETURN if same as keystore password):</programlisting>

      <para>Since did not specify the -keystore filename parameter, created
      the keystore in $HOME/.keystore (or C:\Documents and
      Settings\Tom\.keystore).</para>

      <para>Export the RSA certificate (without the private key)</para>

      <programlisting>C:\tmp\ssl&gt;keytool -export -alias remoting -file remoting.cer
Enter keystore password: opensource
Certificate stored in file &lt;remoting.cer&gt;</programlisting>

      <para>Import the RSE certificate into a new truststore file.</para>

      <programlisting>C:\tmp\ssl&gt;keytool -import -alias remoting -keystore .truststore -file remoting.cer
Enter keystore password: opensource
Owner: CN=Tom Elrod, OU=Development, O=JBoss Inc, L=Atlanta, ST=GA, C=US
Issuer: CN=Tom Elrod, OU=Development, O=JBoss Inc, L=Atlanta, ST=GA, C=US
Serial number: 426f1ee3
Valid from: Wed Apr 27 01:10:59 EDT 2005 until: Tue Jul 26 01:10:59 EDT 2005
Certificate fingerprints:
MD5: CF:D0:A8:7D:20:49:30:67:44:03:98:5F:8E:01:4A:6A
SHA1: C6:76:3B:6C:79:3B:8D:FD:FB:4F:33:3B:25:C9:01:9D:50:BF:9F:8A
Trust this certificate? [no]: yes
Certificate was added to keystore</programlisting>

      <para>Now have two files, .keystore for the server and .truststore for
      the client.</para>
    </section>

    <section>
      <title>Troubleshooting Tips</title>

      <para>Common errors when using server socket factory:</para>

      <programlisting>javax.net.ssl.SSLException: No available certificate corresponds to the SSL cipher suites
                            which are enabled.</programlisting>

      <para>The 'javax.net.ssl.keyStore' system property has not been set and
      are using the default SSLServerSocketFactory.</para>

      <programlisting>java.net.SocketException: Default SSL context init failed: Cannot recover key</programlisting>

      <para>The 'javax.net.ssl.keyStorePassword' system property has not been
      set and are using the default SSLServerSocketFactory.</para>

      <programlisting>java.io.IOException: Can not create SSL Server Socket Factory due to the url to the key store
                     not being set.</programlisting>

      <para>The default SSLServerSocketFactory is NOT being used (so custom
      configuration for the server socket factory) and the key store url has
      not been set.</para>

      <programlisting>java.lang.IllegalArgumentException: password can't be null</programlisting>

      <para>The default SSLServerSocketFactory is NOT being used (so custom
      configuration for the server socket factory) and the key store password
      has not been set.</para>
    </section>
  </section>
  
  <section id="section-timeouts" xreflabel="Timeouts">
    <title>Timeouts</title>
    
    <para>
      The handling of timeouts in Remoting is surveyed in this section. On the
      whole, timing out network connections is handled differently by each
      transport, but there are some transport independent methods for timeout
      configuration, extended by some transport specific methods.
    </para>
    
    <section>
      <title>General timeout configuration</title>
      
      <para>
        As with all configuration parameters, there are several avenues for
        specifying parameter values.  See Section <xref
        linkend="section-configuration"/> for a general discussion of parameter
        configuration in Remoting.  The transport independent key for setting
        timeouts is "timeout", also available as
        <code>org.jboss.remoting.ServerInvoker.TIMEOUT</code>.  All server
        invokers also have the getter/setter methods 
      </para>
      
      <programlisting>public int getTimeout();

public void setTimeout(int timeout);</programlisting>
      
      <para>
        where the values are given in milliseconds.  The default timeout value
        is 60000 for server invokers.
      </para>
    </section>
    
    <section>
      <title>Per invocation timeouts</title>
      
      <para>
        As of version 2.4, all Remoting transports offer a per
        invocation transport facility, which allows a timeout value to be set
        for a particular invocation, overriding the client invoker's previously
        configured timeout value. The per invocation timeout is set by passing
        the <classname>String</classname> representation of the timeout value in
        the invocation's metadata map, using the key "timeout". For example,
      </para>
      
      <programlisting>HashMap metadata = new HashMap();
metadata.put("timeout", "2000");
client.invoke("testInvocation", metadata);</programlisting>
      
      <para>
        will allow approximately 2 seconds for this particular invocation, after
        which the timeout value will be reset to its previously configured
        value.
      </para>
      
      <para>
        Each transport handles per invocation timeouts a little differently.
        More details are given below.
      </para>
    </section>
    
    <section>
      <title>Transport specific timeout handling</title>
      
      <section>
        <title>Socket and bisocket transports</title>
        
        <para>
          These two transports are handled together because bisocket inherits
          most of its timeout handling from socket. The discussion also applies
          to their SSL versions, sslbisocket and sslsocket. On the server side,
          the timeout value, whatever the source of its value, is used to set
          the timeout value of all <classname>Socket</classname>s managed by the
          server invoker's worker threads. On the client side, the configured
          timeout value is used to limit the time required by
          <methodname>Socket.connect()</methodname> when a new
          <classname>Socket</classname> is created, as well as to set the
          <classname>Socket</classname> timeout value for all connections in its
          connection pool.
        </para>
        
        <para>
          The socket and bisocket transports support per invocation timeouts.
          The processing subject to the timeout period starts when the client
          invoker begins to acquire a network connection and extends to the
          point at which it begins reading the reponse to the invocation.  Note
          that the acquisition of the network connection might involve multiple
          attempts to connect to the server.
        </para>
        
        <section>
          <title><emphasis role="bold">Write timeouts</emphasis></title>
          
          <para>The socket timeout facility offered by the JDK applies only to 
          <methodname>read</methodname> operations on the socket.  As of
          release 2.5.2, the socket and bisocket (and also sslsocket and sslbisocket)
          transports offer a <emphasis role="bold">write timeout</emphasis> facility.
          When a client or server is configured, in any of the usual ways, with the parameter
          <code>org.jboss.remoting.transport.socket.SocketWrapper.WRITE_TIMEOUT</code>
          (actual value "writeTimeout") set to a positive value (in milliseconds), all
          write operations will time out if they do not complete within the configured
          period.  When a write operation times out, the socket upon which the write was
          invoked will be closed, which is likely to result in a 
          <classname>java.net.SocketException</classname>.</para>
          
          <para><emphasis role="bold">Note.</emphasis> A 
          <classname>SocketException</classname> is considered to be a "retriable"
          exception, so, if the parameter "numberOfCallRetries" is set to a value
          greater than 1, an invocation interrupted by a write timeout can be 
          retried.</para>
          
          <para><emphasis role="bold">Note.</emphasis> The write timeout facility
          applies to writing of both invocations and responses.  It applies to 
          push callbacks as well.</para>
        </section>
      </section>
      
      <section>
        <title>HTTP and HTTPS transports</title>
        
        <para>
          The http server invoker looks for a configured timeout value at
          initialization time, which it uses to set the "connectionTimeout"
          property on its Tomcat connector.  (See Section <xref
          linkend="section-http-invoker"/> for more information.)  Note that
          subsequent calls to <methodname>setTimeout()</methodname> will have no
          effect.
        </para>
        
        <para>
          The http client invoker treats timeouts configured for the connection
          and per invocation timeouts the same, since it opens a new
          <classname>HttpURLConnection</classname> with each invocation.  Any
          nonnegative per invocation timeout value will override a timeout value
          configured at client invoker creation time.
        </para>
        
        <para>
          If the application is using a jdk of generation 1.5 or later, then the
          client invoker will use the
          <classname>java.net.HttpURLConnection</classname> methods
          <methodname>setConnectTimeout()</methodname> and
          <methodname>setReadTimeout()</methodname> methods. Note that in this
          case the timeout value will be allowed twice, once to create the
          connection and once to read the invocation result.
        </para>
        
        <para>
          If an earlier jdk is being used, the client invoker will simulate a
          timeout by making the connection and executing the invocation in a
          separate thread, which it waits on for the specified timeout.  The
          threads are drawn from a thread pool, which is configurable. A custom
          thread pool may be set by calling the
          <classname>HTTPClientInvoker</classname> method
        </para>
        
        <programlisting>public void setTimeoutThreadPool(org.jboss.util.threadpool.ThreadPool pool);</programlisting>
        
        <para>
          where the <methodname>ThreadPool</methodname> interface is available
          from the anonomous JBoss svn repository at <ulink
          url="http://anonsvn.jboss.org/repos/common/common-core/trunk/src/main/java">
          http://anonsvn.jboss.org/repos/common/common-core/trunk/src/main/java/</ulink>.
          If a thread pool is not set, it will default to an instance of
          <classname>org.jboss.util.threadpool.BasicThreadPool</classname>,
          which may be configured with the following parameters,
          defined as constants in
          <classname>org.jboss.remoting.transport.http.HTTPClientInvoker</classname>:
      </para>
      
      <para>
        <emphasis role="bold">MAX_NUM_TIMEOUT_THREADS</emphasis> (actual value
        "maxNumTimeoutThreads"): the number of threads in the threadpool.  The
        default value is 10.
      </para>
      
      <para>
        <emphasis role="bold">MAX_TIMEOUT_QUEUE_SIZE</emphasis> (actual value
        "maxTimeoutQueueSize"): the size of the thread pool queue, which holds
        execution requests when all of the threads are in use.  The default
        value is 1024.
      </para>
      
      </section>
      
      <section>
        <title>RMI and SSLRMI transports</title>
        
        <para>Connection timeouts are handled on the server side by passing the
        configured timeout value to the
        <classname>org.jboss.remoting.transport.rmi.RemotingRMIClientSocketFactory</classname>
        and
        <classname>org.jboss.remoting.transport.rmi.RemotingRMIServerSocketFactory</classname>
        objects passed when the
        <classname>org.jboss.remoting.transport.RMIServerInvoker</classname> is
        exported by the
        <methodname>java.rmi.server.UnicastRemoteObject.exportObject(</methodname>)
        method.</para>
        
        <para><classname>org.jboss.remoting.transport.rmi.RMIClientInvoker</classname>
        handles per invocation timeouts by executing the invocation in a
        separate thread, which it waits on for the specified timeout. The
        threads are drawn from a
        <classname>org.jboss.util.threadpool.BasicThreadPool</classname>, which
        may be configured with the following parameters, defined as constants in
        <classname>org.jboss.remoting.transport.rmi.RMIClientInvoker</classname>:
        </para>
      
        <para>
        <emphasis role="bold">MAX_NUM_TIMEOUT_THREADS</emphasis> (actual value
        "maxNumTimeoutThreads"): the number of threads in the threadpool.  The
        default value is 10.</para>
      
        <para>
        <emphasis role="bold">MAX_TIMEOUT_QUEUE_SIZE</emphasis> (actual value
        "maxTimeoutQueueSize"): the size of the thread pool queue, which holds
        execution requests when all of the threads are in use.  The default
        value is 1024.</para>

      </section>
      
      <section>
        <title>Quick client disconnect</title>
        
        <para>
          <classname>org.jboss.remoting.Client</classname> applies per
          invocation timeouts in its <methodname>removeListener()</methodname>
          and <methodname>disconnect()</methodname> methods to create a "quick
          disconnect" facility. If, for example, an
          <methodname>org.jboss.remoting.ConnectionValidator</methodname> (see
          <xref linkend="chapter-connection-failure"/>) reports its suspicion
          that a connection is failing, the application might want to restrict,
          or even eliminate, the time spent trying to access the network
          while unregistering callback handlers and disconnecting.
          The quick disconnect facility is invoked by calling the
          <classname>Client</classname> method
        </para>
        
        <programlisting>public void setDisconnectTimeout(int disconnectTimeout);</programlisting>
        
        <para>
          to set the disconnect timeout value to a nonnegative value.
          If the disconnect timeout value is set, it will be applied as the per
          invocation timeout value for all network activity in the methods
          <methodname>removeListener()</methodname> and
          <methodname>disconnect()</methodname>.  As a special case, if the
          disconnect timeout value is set to 0, <classname>Client</classname>
          will simply skip any network i/o in these two methods.
        </para>
        
      </section>
    </section>
    
  </section>

  
  <section id="section-security" xreflabel="Timeouts">
     <title>Running with a security manager</title>
    
     <para>As of version 2.4, Remoting is prepared to run in the presence of an
     installed <classname>java.lang.SecurityManager</classname>. In Java,
     certain security sensitive system calls, e.g.,
     <methodname>java.io.File.exists()</methodname>,
     <methodname>java.lang.Class.getClassLoader()</methodname>, and
     <methodname>java.lang.System.getProperty()</methodname>, consult a
     <classname>SecurityManager</classname>, if one has been installed, to
     determine if the calling code has permission to execute the action
     performed by the method.</para>
     
     <para>In fact, the standard behavior is for the Java Virtual Machine to
     examine, not only the calling code, but all methods on the stack, for the
     appropriate permissions. This strategy prevents untrusted code from using
     trusted code for its own nefarious purposes. However, the same strategy
     could prevent trusted code from accomplishing security sensitive activities
     without granting suitable permissions to any code that calls the trusted
     code. The loophole that gets around this problem is the ability to wrap
     security sensitive method calls in a "privileged block" which prevents the
     JVM from proceeding up the stack. In other words, the code in the privileged
     block can employ its granted permissions even if the calling code does not
     have those same permissions.</para>
     
     <para>More precisely, a privileged block consists of an
     <classname>java.security.PrivilegedAction</classname> or
     <classname>java.security.PrivilegedExceptionAction</classname> object
     passed to a                                                         
     <methodname>java.security.AccessController.doPrivileged()</methodname>
     call. As of version 2.4, Remoting wraps all security sensitive method calls
     appropriately. For example, the call
     <code>java.net.ServerSocket.accept()</code> has been replaced by
     org.jboss.remoting.utility.SecurityUtility.accept():</para>
     
     <programlisting>static public Socket accept(final ServerSocket ss) throws IOException
{
   if (skipAccessControl)
   {
      return ss.accept();
   }

   try
   {
      return (Socket)AccessController.doPrivileged( new PrivilegedExceptionAction()
      {
         public Object run() throws Exception
         {
            return ss.accept();
         }
      });
   }
   catch (PrivilegedActionException e)
   {
      throw (IOException) e.getCause();
   }
}</programlisting>
     
     <para>Note that the
     <methodname>AccessController.doPrivileged()</methodname> call, with its
     creation of a <classname>PrivilegedExceptionAction</classname> object, is
     made only if the static variable
     <code>SecurityUtility.skipAccessControl</code> is set to false, which is
     the case if</para>
     
     <itemizedlist>
        <listitem>
           <para>no <classname>SecurityManager</classname> is installed, or</para>
        </listitem>
        <listitem>
           <para>the system property <code>org.jboss.remoting.Remoting.SKIP_ACCESS_CONTROL</code>
           is set to "false".</para>
        </listitem>
     </itemizedlist>
     
     <para>The Remoting code needs quite a few permissions since it interacts
     extensively with the network, file system, etc., and there are a couple of
     strategies for granting these permissions. The standard
     <classname>java.lang.SecurityManager</classname> can read permission
     information from an XML file, as described in <ulink
     url="http://java.sun.com/j2se/1.5.0/docs/guide/security/PolicyFiles.html">
     http://java.sun.com/j2se/1.5.0/docs/guide/security/PolicyFiles.html</ulink>,
     and one straightforward strategy is to treat Remoting as highly trusted
     code and to give it all possible permissions in a file that looks
     like</para>
     
     <programlisting>grant codeBase "file:${remoting.dir}/jboss-remoting.jar"
{
   permission java.security.AllPermission;
};</programlisting>
  
     <para>This file grants all permissions to any class loaded from
     jboss-remoting.jar. Alternatively, a more precisely tailored set of
     permissions can be crafted to give Remoting, or some subset of its
     facilities, sufficient permissions to function. The Remoting distribution
     contains a sample permission set in etc/remoting.security.policy.core. It
     may be necessary or desirable to modify the file, according to which
     Remoting components are used, where certain files are located, etc:</para>
  
     <orderedlist>
        <listitem>
           <para>It may be necessary to change the java.io.FilePermission
           permissions, according to the configuration of certain files.</para>        </listitem>
        <listitem>
           <para>If Remoting is configured to operate with one or more MBeans in
           place of POJOs, it might be necessary to grant additional
           MBeanPermissions.</para>
        </listitem>
        <listitem>
           <para>Some facilities always use MBeans. The MBean permissions given
           in remoting.security.policy.core may be restricted to particular
           ObjectNames.</para>
        </listitem>
        <listitem>
           <para>Some permission may be eliminated, according to which Remoting
           facilities are used.</para>
        </listitem>
     </orderedlist>

     <para>Other than changes made according to items 1 and 2, it should not be
     necessary to grant any additional permissions.</para>
     
     <para>The etc directory also contains the policy files
     remoting.security.policy.tests, remoting.security.policy.tests.marshal, and
     remoting.security.policy.tests.minimal, which are used by the Remoting
     functional test suite. These files give examples of modifying the
     permissions given in remoting.security.policy.core.</para>
     
     <para><emphasis role="bold">Note. </emphasis>As of release 2.5.3, state changing methods
     of <classname>org.jboss.remoting.InvokerRegistry</classname> require permission
     <code>java.lang.RuntimePermission("invokerRegistryUpdate")</code>.  These methods
     are</para>
     
     <itemizedlist>
        <listitem>
           <para>createClientInvoker()</para>
        </listitem>
        <listitem>
           <para>createServerInvoker()</para>
        </listitem>
        <listitem>
           <para>destroyClientInvoker()</para>
        </listitem>
        <listitem>
           <para>destroyServerInvoker()</para>
        </listitem>
        <listitem>
           <para>isSSLSupported()</para>
        </listitem>
        <listitem>
           <para>registerInvokerFactories()</para>
        </listitem>
        <listitem>
           <para>unregisterInvokerFactories()</para>
        </listitem>
        <listitem>
           <para>unregisterLocator()</para>
        </listitem>
        <listitem>
           <para>updateServerInvokerLocator()</para>
        </listitem>
     </itemizedlist>
     
     <para>Sample policy file etc/remoting.security.policy.core has been modified accordingly.</para>
     
  </section>
  
  <section id="section-wire-version" xreflabel="Wire version">
     <title>Wire version</title>
     
     <para>Remoting has, on occasion, changed the format of communications over
     the network, which could make it difficult for one version of Remoting to
     communcate with another version. However, it is possible to configure newer
     versions to communicate with older versions.</para>
     
     <para>There are currently three wire versions:</para>
     
     <itemizedlist>
       <listitem>
         <code>org.jboss.remoting.Version.VERSION_1</code> (actual value 1),
         used by Remoting versions 1.2 and 1.4;
       </listitem>
       
       <listitem>
         <code>org.jboss.remoting.Version.VERSION_2</code> (actual value 2),
         used by Remoting version 2.0; and
       </listitem>
       
       <listitem>
         <code>org.jboss.remoting.Version.VERSION_22</code> (actual value 22),
         used by Remoting versions 2.2 and 2.4.
       </listitem>
     </itemizedlist>
     
     <para>Versinos 2.0, 2.2, and 2.4 can be configured to communicate with
     versions 1.2 and 1.4 in one of three ways:</para>
     
     <orderedlist>
        <listitem>
           <para>set system property
           <code>org.jboss.remoting.Version.PRE_2_0_COMPATIBLE</code> (actual
           value "jboss.remoting.pre_2_0_compatible") to "true";</para>
        </listitem>
        
        <listitem>
           <para>set system property
           <code>org.jboss.remoting.Version.REMOTING_VERSION_TO_USE</code>
           (actual value "jboss.remoting.version") to
           <code>org.jboss.remoting.Version.VERSION_1</code> (actual version
           "1");</para>
        </listitem>
        
        <listitem>
           <para>configure the <classname>org.jboss.remoting.Client</classname>
           or <classname>org.jboss.remoting.transport.Connector</classname> with
           the parameter
           <code>org.jboss.remoting.Remoting.REMOTING_VERSION</code> (actual
           value "remotingVersion") set to
           <code>org.jboss.remoting.Version.VERSION_1</code> (actual version
           "1").</para>
        </listitem>
     </orderedlist>
     
     <para>Similarly, versions 2.2 and 2.4 can be configured to communicate with
     version 2.0:</para>
     
     <orderedlist>
        <listitem>
           <para>set system property
           <code>org.jboss.remoting.Version.REMOTING_VERSION_TO_USE</code>
           (actual value "jboss.remoting.version") to
           <code>org.jboss.remoting.Version.VERSION_2</code> (actual version
           "2");</para>
        </listitem>
        
        <listitem>
           <para>configure the <classname>org.jboss.remoting.Client</classname>
           or <classname>org.jboss.remoting.transport.Connector</classname> with
           the parameter
           <code>org.jboss.remoting.Remoting.REMOTING_VERSION</code> (actual
           value "remotingVersion") set to
           <code>org.jboss.remoting.Version.VERSION_2</code> (actual version
           "2").</para>
        </listitem>
     </orderedlist>
     
     <para>Versions 2.2. and 2.4 use the same wire format, so there's no need to
     configure version 2.4 to communicate with version 2.2.</para>
     
     <para><emphasis role="bold">Note. </emphasis> Setting these versions is not
     necessary in all circumstances. For example, it is not necessary when using
     JBossSerialization. But, upon encountering a problem when using mismatched
     clients and servers, be sure that the versions are set properly.</para>
   
  </section>
  
  
  <section id="section-configuration-by-properties" xreflabel="Configuration by properties">
    <title>Configuration by properties</title>

    <para>This section covers configuration properties by constant values and
    bean properties for individual classes. This will duplicate some of the
    configuration properties already covered and is just another view to some
    of the same information.</para>

    <section>
    <title>org.jboss.remoting.InvokerLocator</title>

    <para><emphasis role="bold">SERVER_BIND_ADDRESS</emphasis> (actual value
    is 'jboss.bind.address') - indicates the system property key for bind
    address that should be used.</para>

    <para><emphasis role="bold">BIND_BY_HOST</emphasis> (actual value is
    'remoting.bind_by_host') - indicates the system property key for if the
    local bind address should be by host name (e.g.
    InetAddress.getLocalHost().getHostName()) or if should be by IP (e.g.
    InetAddress.getLocalHost().getHostAddress()). The default is 'True',
    meaning will will use local host name. This configuration only applies
    when the initial bind address is 0.0.0.0 (or InvokerLocator.ANY).</para>

    <para><emphasis role="bold">DATATYPE</emphasis> (actual value is
    'datatype') - indicates the marshalling datatype that should be used for a
    particular invoker. Each invoker has its own default marshaller and
    unmarshaller based on default datatype. For examle, the socket transport
    has a default datatype of 'serializable', which is automatically
    registered with the MarshalFactory and associated by default with
    org.jboss.remoting.marshal.serializable.SerializableMarshaller and
    org.jboss.remoting.marshal.serializable.SerializableUnMarshaller. The
    marshaller and unmarshaller used by an invoker can be overriden by setting
    the 'datatype' parameter within the LocatorInvoker. For example, could use
    a locator url of:</para>

    <programlisting>socket://myhost:6500/?datatype=test</programlisting>

    <para>which would cause the socket invoker to use the marshaller and
    unmarshaller registered with the MarshalFactory under the datatype 'test'.
    Of course, this requires that the marshaller and unmarshaller
    implementations to be used have already been registered with the
    MarshalFactory (otherwise will get an exception).</para>

    <para><emphasis role="bold">SERIALIZATIONTYPE</emphasis> (actual value is
    'serializationtype') - indicates the serialization implementation to use.
    Currently, the only possible values are 'java' and 'jboss'. Java
    serialization is the default. Setting to 'jboss' will cause JBoss
    Serialization to be used. In implementation, this equates to the parameter
    that will be passed to the SerializationStreamFactory.getManagerInstance()
    method. This configuration can be set as an invoker locator url parameter
    (e.g. socket://myhost:5400/?serializationtype=jboss) or as an entry to the
    configuration Map passed when constructing a remoting client or
    server.</para>

    <para><emphasis role="bold">MARSHALLER</emphasis> (actual value is
    'marshaller') - used to indicate which marshaller implementation should be
    used by the invoker. This is an override for whatever the invoker's
    default implementation is. This can be set as a parameter of the invoker
    locator url (e.g.
    socket://myhost:6500/?marshaller=org.jboss.test.remoting.marshall.dynamic.remote.http.TestMarshaller).
    Using this configuration requires that the value be the fully qualified
    classname of the marshaller implementation to use (which must be on the
    classpath, have a void constructor, and implement the
    org.jboss.remoting.marshal.Marshaller interface).</para>

    <para><emphasis role="bold">UNMARSHALLER</emphasis> (actual value is
    'unmarshaller') - used to indicate which unmarshaller implementation
    should be used by the invoker. This is an override for whatever the
    invoker's default implementation is. This can be set as a parameter of the
    invoker locator url (e.g.
    socket://myhost:6500/?unmarshaller=org.jboss.test.remoting.marshall.dynamic.remote.http.TestUnMarshaller).
    Using this configuration requires that the value be the fully qualified
    classname of the unmarshaller implementation to use (which must be on the
    classpath, have a void constructor, and implement the
    org.jboss.remotng.marshal.UnMarshaller interface).</para>

    <para><emphasis role="bold">LOADER_PORT</emphasis> (actual value is
    'loaderport') - indicates the port number where the class loader server
    resides. This can be used when is possible that a client may not have
    particular classes locally and would want to load them from the server
    dynamically. This property can be set as a parameter to the invoker
    locator url. A clasic example of when this might be used would be in
    conjunction with using custom marshalling. For example, if have configured
    a server to use custom marshaller and unmarshaller that the client will
    not have access to, could create a invoker locator such as:</para>

    <programlisting>socket://myhost:6500/?datatype=test&amp;loaderport=6501&amp;
        marshaller=org.jboss.test.remoting.marshall.dynamic.remote.http.TestMarshaller&amp;
        unmarshaller=org.jboss.test.remoting.marshall.dynamic.remote.http.TestUnMarshaller</programlisting>

    <para>When the client invoker begins to make an invocation, will try to
    look up marshaller and unmarshaller based on type ('test' in this case)
    and when can not find a registry entry for it, will try to load the
    TestMarshaller and TestUnMarshaller from the classpath. When the classes
    can not be found locally, will make a call to the loader server (on port
    6501) to load the classes locally. Once they are retrieved from the
    server, will be registered locally, so is a one time only event (as next
    time will be found in the registry).</para>

    <para>This can work for loading any remote server classes, but requires
    the loaderport be included in the invoker locator url.</para>

    <para><emphasis role="bold">BYVALUE</emphasis> (actual value is 'byvalue')
    - indicates if when making local invocations (meaning client and server
    invoker exists within same jvm), the marshalling will be done by value,
    instead of the default, by reference. Using this configuration, the
    marshalling will actually perform a clone of the object instance (see
    org.jboss.remoting.serialization.SerializationManager.createMarshalledValueForClone()).
    Value for this property should be of type String and be either 'true' or
    'false'. In releases prior to 2.0.0, using this configuration setting
    would have forced invokers to be remote, which can now be done via
    FORCE_REMOTE config (see below).</para>

    <para><emphasis role="bold">FORCE_REMOTE</emphasis> (actual value is
    'force_remote') - indicates if when making local invocations (meaning
    client and server invoker exists within same jvm), the remote invokers
    should be used instead of local invoker. Is equivalent to making
    invocations as though client and server were in different jvms). Value for
    this property should be of type String and be either 'true' or
    'false'.</para>

    <para><emphasis role="bold">CLIENT_LEASE</emphasis> (actual value is
    'leasing') - indicates if client should try to automatically establish a
    lease with the server. Is false by default. Value for this property should
    be of type String and be either 'true' or 'false'.</para>

    <para><emphasis role="bold">CLIENT_LEASE_PERIOD</emphasis> (actual value
    is 'lease_period') - defines what the client lease period should be in the
    case that server side leasing is turned on. Value for this parameter key
    should be the number of milliseconds to wait before each client lease
    renewal and must be greater than zero in order to be recognized. If this
    property is not set (and CLIENT_LEASE is), will use the lease period as
    specified by the server.</para>
    
    <para><emphasis role="bold">SUPPRESS_HOST_WARNING</emphasis> (actual value is
    'suppressHostWarning') - the boolean valued system property that determines if 
    <classname>InvokerLocator</classname> should log a warning that the hostname is
    null.  The default value is "false", i.e., the warning is logged by default.</para>

    </section>

    <section>
    <title>org.jboss.remoting.Client</title>

    <para><emphasis role="bold">RAW</emphasis> (actual value is 'rawPayload')
    - key to use for the metadata Map passed when making an invoke() call and
    wish for the invocation payload to be sent as is and not wrapped within a
    remoting invocation request object. This should be used when want to make
    direct calls on systems outside of remoting (e.g. making an http POST
    request to a web service).</para>

    <para><emphasis role="bold">ENABLE_LEASE</emphasis> (actual value is
    'enableLease') - key for the configuration map passed to the Client
    constructor to indicate that client should make initial request to
    establish lease with server. The value for this should be either a String
    that java.lang.Boolean can evaluate or a java.lang.Boolean. By default,
    leasing is turned off, so this property would be used to turn on leasing
    for the client.</para>

    <para><emphasis role="bold">HANDSHAKE_COMPLETED_LISTENER</emphasis>
    (actual value is 'handshakeCompletedListener') - key for the configuration
    map passed to the Client constructor providing a ssl
    javax.net.ssl.HandshakeCompletedListener implementation, which will be
    called on when ssl handshake completed with server.</para>

    <para><emphasis role="bold">USE_ALL_PARAMS</emphasis>
    (actual value is 'useAllParameters') - used by
    <classname>org.jboss.remoting.ConnectionValidator</classname> and
    <classname>org.jboss.remoting.callback.CallbackPoller</classname> to
    determine if configuration parameters should be retrieved from the
    <classname>InvokerLocator</classname> or the 
    <classname>Client</classname>'s configuration map.</para>
    
    <para></para>

    <para>The following three configuration properties are only useful when
    using one of the following Client methods:</para>

    <programlisting>public void addListener(
        InvokerCallbackHandler callbackhandler, Map metadata,
        Object callbackHandlerObject) throws Throwable
public void addListener(
        InvokerCallbackHandler callbackhandler, Map metadata,
        Object callbackHandlerObject, boolean serverToClient) throws Throwable</programlisting>

    <para><emphasis role="bold">CALLBACK_SERVER_PROTOCOL</emphasis> (actual
    value is 'callbackServerProtocol') - key for the configuration when adding
    a callback handler and internal callback server connector is created. The
    value should be the transport protocol to be used. By default will use the
    same protocol as being used by this client (e.g. http, socket, rmi,
    etc.).</para>

    <para><emphasis role="bold">CALLBACK_SERVER_HOST</emphasis> (actual value
    is 'callbackServerHost') - key for the configuration when adding a
    callback handler and internal callback server connector is created. The
    value should be the host name to be used. By default will use the result
    of calling InetAddress.getLocalHost().getHostAddress().</para>

    <para><emphasis role="bold">CALLBACK_SERVER_PORT</emphasis> (actual value
    is 'callbackServerPort') - key for the configuration when adding a
    callback handler and internal callback server connector is created. The
    value should be the port to be used. By default will find a random unused
    port.</para>

    <para></para>

    <para><emphasis role="bold">Bean properties (meaning have
    getter/setter):</emphasis></para>

    <para><emphasis role="bold">SessionId</emphasis> - session id used when
    making invocations on server invokers. There is a default unique id
    automatically generated for each Client instance, so unless you have a
    good reason to set this, do not set this.</para>

    <para><emphasis role="bold">Subsystem</emphasis> - the subsystem being
    used when routing invocation requests on the server side. Specifing a
    subsystem is only needed when server has multiple handlers registered
    (which will each have their own associated subsystem). Best if specified
    using Client constructor.</para>

    <para><emphasis role="bold">MaxNumberOfThreads</emphasis> - the maximum
    number of threads to use within client pool for one way invocations on the
    client side (meaning oneway invocation is handled by thread in this pool
    and user's call returns immediately) Default value is
    MAX_NUM_ONEWAY_THREADS (whose value is 10).</para>

    <para><emphasis role="bold">OnewayThreadPool</emphasis> - the thread pool
    being used for making one way invocations on the client side. If one has
    not been specifically set via configuration or call to set it, will always
    return instance of org.jboss.util.threadpool.BasicThreadPool.</para>

    <para><emphasis role="bold">SocketFactory</emphasis> - instance of
    javax.net.SocketFactory, which can only be set on the Client before the
    connect() method has been called. Otherwise, a runtime exception will be
    thrown.</para>

    <para><emphasis role="bold">Marshaller</emphasis> - the marshaller
    implementation that should be used by the client invoker (transport). This
    overrides the client's default marshaller (or any set within
    configuration).</para>

    <para><emphasis role="bold">UnMarshaller</emphasis> - the unmarshaller
    implementation that should be used by the client invoker (transport). This
    overrides the client's default unmarshaller (or any set within
    configuration).</para>

    </section>

    <section id="section-org-jboss-remoting-Remoting" xreflabel="org.jboss.remoting.Remoting">
    <title>org.jboss.remoting.Remoting</title>

    <para><emphasis role="bold">CUSTOM_SERVER_SOCKET_FACTORY</emphasis>
    (actual value is 'customServerSocketFactory') - key for the configuration
    map passed to a Connector to indicate the server socket factory to be
    used. This will override the creation of any other socket factory. Value
    must be an instance of javax.net.ServerSocketFactory.</para>

    <para><emphasis role="bold">CUSTOM_SOCKET_FACTORY</emphasis> (actual value
    is 'customSocketFactory') - key for the configuration map passed to a
    Client to indicate the socket factory to be used. Value must be instance
    of javax.net.SocketFactory.</para>

    <para><emphasis role="bold">SOCKET_FACTORY_CLASS_NAME</emphasis> (actual value
    is 'socketFactoryClassName') - key for the configuration map passed to a Client to
    indicate the classname of the socket factory to be used. Value should be
    fully qualified classname of class that is an instance of
    javax.net.SocketFactory and has a void constructor. This property will not
    be used if CUSTOM_SOCKET_FACTORY is also set.</para>

    <para><emphasis role="bold">SOCKET_CREATION_CLIENT_LISTENER</emphasis>
    (actual value is "socketCreationClientListener") - key for the configuration
    map passed to a Client or Connector to indicate a socket creation listener
    for sockets created by a SocketFactory.</para>
    
    <para><emphasis role="bold">SOCKET_CREATION_SERVER_LISTENER</emphasis>
    (actual value is "socketCreationServerListener") - key for the configuration
    map passed to a Client or Connector to indicate a socket creation listener
    for sockets created by a ServerSocket.</para>
   
    <para><emphasis role="bold">CLIENT_ADDRESS</emphasis> (actual value is
    "clientAddress") - key with which host address of client will be associated
    in <classname>InvocationRequest</classname> request payload.</para>

    <para><emphasis role="bold">REMOTING_VERSION</emphasis> (actual value is
    "remotingVersion") - key for configuring Remoting wire version.</para>
    
    <para><emphasis role="bold">SKIP_ACCESS_CONTROL</emphasis> (actual value is
    "skipAccessControl") - key for telling Remoting to execute security
    sensitive code outside of
    <methodname>java.security.AccessController.doPrivileged()</methodname>
    calls..</para> 

    <para><emphasis role="bold">CONFIG_OVERRIDES_LOCATOR</emphasis> (actual value is
    "configOverridesLocator") - key for indicating that parameter values found
    in the configuration map passed to an <classname>org.jboss.remoting.Client</classname>
    constructor should take precedence over values found in the 
    <classname>InvokerLocator</classname>.</para> 
    
    <para><emphasis role="bold">USE_CLIENT_CONNECTION_IDENTITY</emphasis>
    (actual value "useClientConnectionIdentity") - tells Remoting to adhere to the
    new "connection identity" semantics described in Chapter
    <xref linkend="chapter-connection-failure"/>.</para>
    
    <para><emphasis role="bold">PASS_CONFIG_MAP_TO_MARSHAL_FACTORY</emphasis>
    (actual value "passConfigMapToMarshalFactory") - if set to "true", tells clients and servers
    to take parameters for configuring marshallers and unmarshallers from the
    configuration map passed to <classname>Client</classname>s and
    <classname>Connector</classname>s in addition to the parameters in the
    <classname>InvokerLocator</classname>.</para>
    
    </section>

    <section>
    <title>org.jboss.remoting.ServerInvoker</title>

    <para><emphasis role="bold">MAX_NUM_ONEWAY_THREADS_KEY</emphasis> (actual
    value is 'maxNumThreadsOneway') - key for the maximum number of threads to
    be used in the thread pool for one way invocations (server side). This
    property is only used when the default oneway thread pool is used.</para>

    <para><emphasis role="bold">ONEWAY_THREAD_POOL_CLASS_KEY</emphasis>
    (actual value is 'onewayThreadPool') - key for setting the setting the
    oneway thread pool to use. The value used with this key will first be
    checked to see if is a JMX ObjectName and if so, try to look up associated
    mbean for the ObjectName given and cast to type
    org.jboss.util.threadpool.ThreadPoolMBean (via
    MBeanServerInvocationHandler.newProxyInstance()). If the value is not a
    JMX ObjectName, will assume is a fully qualified classname and load the
    coresponding class and create a new instance of it (which will require it
    to have a void constructor). The newly created instance will then be cast
    to type of org.jboss.util.threadpool.ThreadPool.</para>

    <para><emphasis role="bold">SERVER_BIND_ADDRESS_KEY</emphasis> (actual
    value is 'serverBindAddress') - key for setting the address the server
    invoker should bind to. The value can be either host name or IP.</para>

    <para><emphasis role="bold">CLIENT_CONNECT_ADDRESS_KEY</emphasis> (actual
    value is 'clientConnectAddress') - key for setting the address the client
    invoker should connecto to. This should be used when client will be
    connecting to server from outside the server's network and the external
    address is different from that of the internal address the server invoker
    will bind to (e.g. using NAT to expose different external address). This
    will mostly be useful when client uses remoting detection to discover
    remoting servers. The value can be either host name or IP.</para>

    <para><emphasis role="bold">SERVER_BIND_PORT_KEY</emphasis> (actual value
    is 'serverBindPort') - key for setting the port the server invoker should
    bind to. If the value supplied is less than or equal to zero, the server
    invoker will randomly choose a free port to use.</para>

    <para><emphasis role="bold">CLIENT_CONNECT_PORT_KEY</emphasis> (actual
    value is 'clientConnectPort') - key for setting the port the client
    invoker should connect to. This should be used when client will be
    connecting to server from outside the server's network and the external
    port is different from that of the internal port the server invoker will
    bind to (e.g. using NAT to expose different port routing). This will be
    mostly useful when client uses remoting detection to discover remoting
    servers.</para>

    <para><emphasis role="bold">CLIENT_LEASE_PERIOD</emphasis> (actual value
    is 'clientLeasePeriod') - key used for setting the amount of time (in
    milliseconds) that a client should renew its lease. If this value is not
    set, the default of five seconds (see DEFAULT_CLIENT_LEASE_PERIOD), will
    be used. This value will also be what is given to the client when it
    initially queries server for leasing information.</para>

    <para><emphasis role="bold">TIMEOUT</emphasis> (actual value is 'timeout')
    - key for setting the timeout value (in milliseconds) for socket
    connections.</para>

    <para><emphasis role="bold">SERVER_SOCKET_FACTORY</emphasis> (actual value
    is 'serverSocketFactory') - key for setting the value for the server
    socket factory to be used by the server invoker. The value can be either a
    JMX Object name, in which case will lookup the mbean and create a proxy to
    it with type of org.jboss.remoting.security.ServerSocketFactoryMBean (via
    MBeanServerInvocationHandler.newProxyInstance()), or, if not a JMX
    ObjectName, will assume is the fully qualified classname to the
    implementation to be used and will load the class and create a new
    instance of it (which requires it to have a void constructor). The
    instance will then be cast to type javax.net.ServerSocketFactory.</para>

    <para>
      <emphasis role="bold">BLOCKING_MODE</emphasis> (actual value is
      "blockingMode"): if set to <code>ServerInvoker.BLOCKING</code> (actual
      value "blocking"),
      <methodname>org.jboss.remoting.Client.getCallbacks()</methodname> will do
      blocking pull callbacks and <classname>CallbackPoller</classname> will do
      blocking polled callbacks; if set to
      <code>ServerInvoker.NONBLOCKING</code> (actual value "nonblocking"),
      <methodname>Client.getCallbacks()</methodname> will do non-blocking pull
      callbacks and <classname>CallbackPoller</classname> will do non-blocking
      polled callbacks.
    </para>
    
    <para>
      <emphasis role="bold">BLOCKING_TIMEOUT</emphasis> (actual value is
      "blockingTimeout"): the timeout value used for blocking callback.
    </para>
          
    <para>
      <emphasis role="bold">REGISTER_CALLBACK_LISTENER</emphasis> (actual value
      is "registerCallbackListener"): determines if
      <classname>org.jboss.remoting.callback.ServerInvokerCallbackHandler</classname>s
      should register as
      <classname>org.jboss.remoting.ConnectionListener</classname>s with leases.
      The default value is "true".
    </para>
    
    <para></para>

    <para><emphasis role="bold">Bean properties (meaning have
    getter/setter):</emphasis></para>

    <para><emphasis role="bold">ServerSocketFactory</emphasis> -
    implementation of javax.net.ServerSocketFactory to be used by the server
    invoker. This takes precedence over any other configuration for the server
    socket factory.</para>

    <para><emphasis role="bold">Timeout</emphasis> - timeout (in milliseconds)
    for socket connection. If set after create() method called, this value
    will override value set by TIMEOUT key.</para>

    <para><emphasis role="bold">LeasePeriod</emphasis> - the amount of time
    (in milliseconds) that a client should renew its lease. If this value is
    not set, the default of five seconds (see DEFAULT_CLIENT_LEASE_PERIOD),
    will be used. This value will also be what is given to the client when it
    initially queries server for leasing information. If set after create()
    method called, this value will override value set by CLIENT_LEASE_PERIOD
    key.</para>

    <para><emphasis role="bold">MaxNumberOfOnewayThreads</emphasis> - the
    maximum number of threads to be used in the thread pool for one way
    invocations (server side). This property is only used when the default
    oneway thread pool is used. If set after create() method called, this
    value will override value set by MAX_NUM_ONEWAY_THREADS_KEY key.</para>

    <para><emphasis role="bold">OnewayThreadPool</emphasis> - the oneway
    thread pool to use.</para>

    </section>

    <section>
    <title>org.jboss.remoting.callback.CallbackPoller</title>

    <para><emphasis role="bold">CALLBACK_POLL_PERIOD</emphasis> (actual value
    is 'callbackPollPeriod') - key for setting the frequency (in milliseconds)
    in which Client's internal callback poller should poll server for waiting
    callbacks.  The default value is five seconds.</para>
    
    <para>
      <emphasis role="bold">CALLBACK_SCHEDULE_MODE</emphasis> (actual value is
      "scheduleMode"): may be set to either
      <code>CallbackPoller.SCHEDULE_FIXED_RATE</code> (actual value
      "scheduleFixedRate") or <code>CallbackPoller.SCHEDULE_FIXED_DELAY</code>
      (actual value "scheduleFixedDelay"). In either case, polling will take
      place at approximately regular intervals, but in the former case the
      scheduler will attempt to perform each poll CALLBACK_POLL_PERIOD
      milliseconds after the previous attempt, and in the latter case the
      scheduler will attempt to schedule polling so that the
      <emphasis>average</emphasis> interval will be approximately
      CALLBACK_POLL_PERIOD milliseconds.
      <code>CallbackPoller.SCHEDULE_FIXED_RATE</code> is the default.
    </para>
    
    <para>
      <emphasis role="bold">REPORT_STATISTICS</emphasis> (actual value is
      "reportStatistics"): The presence of this key in <code>metadata</code>,
      regardless of its value, will cause the
      <classname>CallbackPoller</classname> to print statistics that might be
      useful for configuring the other parameters..
    </para>
    
    <para>
      <emphasis role="bold">SYNCHRONIZED_SHUTDOWN</emphasis> (actual value is
      "doSynchronizedShutdown"): if set to "true",
      <methodname>CallbackPoller.stop()</methodname> will wait for
      <methodname>Client.getCallbacks()</methodname> to return, and if set to
      "false" it will not wait. For blocking polled callbacks, the default value
      is "false" and for non-blocking polled callbacks, the default value is
      "true".
    </para>
                    
    <para>
      <emphasis role="bold">MAX_ERROR_COUNT</emphasis> (actual value is
      "maxErrorCount"): determines the maximum number of errors that may
      be experienced during polling before
      <classname>CallbackPoller</classname> will shut itself down. The
      default value is "5".
    </para> 
          
    <para><classname>CallbackPoller</classname>
     configuration is only necessary when using one of the
    following Client methods:</para>

    <programlisting>public void addListener(
        InvokerCallbackHandler callbackhandler, Map metadata,
        Object callbackHandlerObject) throws Throwable
public void addListener(
        InvokerCallbackHandler callbackhandler, Map metadata,
        Object callbackHandlerObject, boolean serverToClient) throws Throwable</programlisting>

    <para>The keys should be among the entries in the metadata Map passed. This
    will also only apply when the underlying transport is uni-directional
    (e.g. socket, http, rmi). Bi-directional transports will not need to poll.
    </para>

    </section>

    <section>
    <title>org.jboss.remoting.callback.CallbackStore</title>

    <para><emphasis role="bold">FILE_PATH_KEY</emphasis> (actual value is
    'StoreFilePath') - key for setting the directory in which to write the
    callback objects. The default value is the property value of
    'jboss.server.data.dir' and if this is not set, then will be 'data'. Will
    then append 'remoting' and the callback client's session id. An example
    would be 'data\remoting\5c4o05l-9jijyx-e5b6xyph-1-e5b6xyph-2'.</para>

    <para><emphasis role="bold">FILE_SUFFIX_KEY</emphasis> (actual value is
    'StoreFileSuffix') - key for setting the file suffix to use for the
    callback objects written to disk. The default value is 'ser'.</para>

    </section>

    <section>
    <title>org.jboss.remoting.callback.DefaultCallbackErrorHandler</title>

    <para><emphasis role="bold">CALLBACK_ERRORS_ALLOWED</emphasis> (actual
    value is 'callbackErrorsAllowed') - key for setting the number of callback
    exceptions that will be allowed when calling on
    org.jboss.remoting.callback.InvokerCallbackHandler.handleCallback(Callback
    callback) before cleaning up the callback listener. This only applies to
    push callback. The default if this property is not set is five.</para>

    </section>

    <section>
    <title>org.jboss.remoting.callback.ServerInvokerCallbackHandler</title>

    <para><emphasis role="bold">CALLBACK_STORE_KEY</emphasis> (actual value is
    'callbackStore') - key for specifing the callback store to be used. The
    value can be either a JMX ObjectName or a fully qualified class name;
    either way, must implement org.jboss.remoting.SerializableStore. If using
    class name, the callback store implementation must have a void
    constructor. The default is to use the
    org.jboss.remoting.callback.NullCallbackStore.</para>

    <para><emphasis role="bold">CALLBACK_ERROR_HANDLER_KEY</emphasis> (actual
    value is 'callbackErrorHandler') - key for specifing the callback
    exception handler to be used. The value can be either a JMX ObjectName or
    a fully qualified class name, either way, must implement
    org.jboss.remoting.callback.CallbackErrorHandler. If using class name, the
    callback exception handler implementation must have a void constructor.
    The default is to use
    org.jboss.remoting.callback.DefaultCallbackErrorHandler.</para>

    <para><emphasis role="bold">CALLBACK_MEM_CEILING</emphasis> (actual value
    is 'callbackMemCeiling') - key for specifying the percentage of free
    memory available before callbacks will be persisted. If the memory heap
    allocated has reached its maximum value and the percent of free memory
    available is less than the callbackMemCeiling, this will trigger
    persisting of the callback message. The default value is 20.</para>
    
    <para><emphasis role="bold">CALLBACK_TIMEOUT</emphasis> (actual value is
    'callbackTimeout') - key for specifying the timeout to be used for doing
    push callbacks. In the absence of
    <code>ServerInvokerCallbackHandler.CALLBACK_TIMEOUT</code>, the timeout
    value configured for the <classname>Connector</classname> will be
    used.</para>

    </section>
    
    <section>
    <title>org.jboss.remoting.detection.jndi.JNDIDetector</title>

    <para><emphasis role="bold">Bean properties (meaning have
    getter/setter):</emphasis></para>

    <para><emphasis role="bold">SubContextName</emphasis> - sub context name
    under which detection messages will be bound and looked up.</para>

    </section>
    
    <section>
    <title>org.jboss.remoting.marshal.http.HTTPUnMarshaller</title>
    
    <para><emphasis role="bold">PRESERVE_LINES</emphasis> (actual value is
    "preserveLines"): the key used to turn on or off
    <classname>HTTPUnMarshaller</classname>'s behavior of stripping CR/LF
    characters.</para>
    
    </section>
    
    <section>
    <title>org.jboss.remoting.transport.bisocket.Bisocket</title>
        <para>
          <emphasis role="bold">IS_CALLBACK_SERVER</emphasis> (actual value is
          "isCallbackServer"): when a bisocket server invoker receives this
          parameter with a value of true, it avoids the creation of a
          <classname>ServerSocket</classname>. Therefore, IS_CALLBACK_SERVER
          should be used on the client side for the creation of a callback
          server. The default value is false.
        </para>
            
        <para>
          <emphasis role="bold">PING_FREQUENCY</emphasis> (actual
          value is "pingFrequency"): The server side uses this value
          to determine the interval, in milliseconds, between pings that it will
          send on the control connection.  The client side uses this value to
          calculate the window in which it must receive pings on the control
          connection.  In particular, the window is ping frequency * ping window factor.
          See also the definition of PING_WINDOW_FACTOR. The default value is 5000.
        </para>
        
        <para>
          <emphasis role="bold">PING_WINDOW_FACTOR</emphasis> (actual
          value is "pingWindowFactor"): The client side uses this value to
          calculate the window in which it must receive pings on the control
          connection.  In particular, the window is ping frequency * ping window factor.
          See also the definition of PING_FREQUENCY. The default value is 2.
        </para>
        
        <para>
          <emphasis role="bold">MAX_RETRIES </emphasis> (actual value is
          "maxRetries"): This parameter is relevant only on the client side,
          where the <classname>BisocketClientInvoker</classname> uses it
          to govern the number of attempts it should make to get the address and
          port of the secondary <classname>ServerSocket</classname>, and the
          <classname>BisocketServerInvoker</classname> uses it to govern the
          number of attempts it should make to create both ordinary and control
          sockets. The default value is 10. </para>
          
        <para>
          <emphasis role="bold">SECONDARY_BIND_PORT</emphasis> (actual value is
          "secondaryBindPort"): The server side uses this parameter to determine
          the bind port for the secondary
          <classname>ServerSocket</classname>.</para>
          
        <para>
          <emphasis role="bold">SECONDARY_BIND_PORTS</emphasis> (actual value is
          "secondaryBindPorts"): The server side uses this parameter to
          determine the bind ports for the secondary
          <classname>ServerSocket</classname>s in a multihome server.</para>
          
        <para>
          <emphasis role="bold">SECONDARY_CONNECT_PORT</emphasis> (actual value
          is "secondaryConnectPort"): The server side uses this parameter to
          determine the connect port used by the client side to connect to the
          secondary <classname>ServerSocket</classname>.</para>
         
        <para>
          <emphasis role="bold">SECONDARY_CONNECT_PORTS</emphasis> (actual value
          is "secondaryConnectPorts"): The server side uses this parameter to
          determine the connect ports used by the client side to connect to the
          secondary <classname>ServerSocket</classname>s in a multihome
          server.</para>
         
    </section>

    <section>
    <title>org.jboss.remoting.transport.http.HTTPClientInvoker</title>
    
        <para> <emphasis role="bold">NUMBER_OF_CALL_ATTEMPTS</emphasis> (actual
        value is "numberOfCallAttempts"): This parameter is relevant only on the
        client side, where it determines the maximum number of attempts that
        will be made to complete an invocation. The default value is 1.</para>
          
        <para><emphasis role="bold">UNMARSHAL_NULL_STREAM</emphasis> (actual value
        is "unmarshalNullStream") - key indicating if
        <classname>org.jboss.remoting.transport.http.HTTPClientInvoker</classname>
        should make the call to <methodname>UnMarshaller.read()</methodname> when
        the <classname>InputStream</classname> is null. The default value is
        "true".</para>
    </section>
    
    <section>
    <title>org.jboss.remoting.transport.http.HTTPMetadataConstants</title>

    <para>The following are keys to use to get corresponding values from the
    Map returned from call to
    org.jboss.remoting.InvocationRequest.getRequestPayload() within a
    org.jboss.remoting.ServerInvocationHandler implementation. For
    example:</para>

    <programlisting>public Object invoke(InvocationRequest invocation) throws Throwable
{
   Map headers = invocation.getRequestPayload();
   ...</programlisting>

    <para>where variable 'headers' will contain entries for the following
    keys.</para>

    <para><emphasis role="bold">METHODTYPE</emphasis> (actual value is
    'MethodType') - key for getting the method type used by client in http
    request. This will be populated within the Map returned from call to
    org.jboss.remoting.InvocationRequest.getRequestPayload() within a
    org.jboss.remoting.ServerInvocationHandler implementation. For
    example:</para>

    <programlisting>public Object invoke(InvocationRequest invocation) throws Throwable
{
   Map headers = invocation.getRequestPayload();
   String methodType = (String) headers.get(HTTPMetadataConstants.METHODTYPE);
   if(methodType != null)
   {
      if(methodType.equals("GET"))
      ...</programlisting>

    <para><emphasis role="bold">PATH</emphasis> (actual value is 'Path') - key
    for getting the path from the url request from the calling client. This
    will be populated within the Map returned from call to
    org.jboss.remoting.InvocationRequest.getRequestPayload() within a
    org.jboss.remoting.ServerInvocationHandler implementation. For
    example:</para>

    <programlisting>public Object invoke(InvocationRequest invocation) throws Throwable
{
   Map headers = invocation.getRequestPayload();
   String path = (String) headers.get(HTTPMetadataConstants.PATH);
   ...</programlisting>

    <para><emphasis role="bold">HTTPVERSION</emphasis> (actual value is
    'HttpVersion') - key for getting the HTTP version from the calling client
    request (e.g. HTTP/1.1).</para>

    <para></para>

    <para></para>

    <para><emphasis role="bold">RESPONSE_CODE</emphasis> (actual value is
    'ResponseCode') - key for getting and setting the HTTP response code. Will
    be used as key to get the response code from metadata Map passed to the
    Client's invoke() method after the invocation has been made. For
    example:</para>

    <programlisting>Map metadata = new HashMap();
Object response = remotingClient.invoke(myPayloadObject, metadata);
Integer responseCode = (Integer) metadata.get(HTTPMetadataConstants.RESPONSE_CODE);</programlisting>

    <para>Will be used as key to put the response code in the return payload
    map from invocation handler. For example:</para>

    <programlisting>public Object invoke(InvocationRequest invocation) throws Throwable
{
   Map responseHeaders = invocation.getReturnPayload();
   responseHeaders.put(HTTPMetadataConstants.RESPONSE_CODE, new Integer(202)); </programlisting>

    <para><emphasis role="bold">RESPONSE_CODE_MESSAGE</emphasis> (actual value
    is 'ResponseCodeMessage') - key for getting and setting the HTTP response
    code message. Will be used as the key to get the response code message
    from metadata Map passed to the Client's invoke() method after the
    invocation has been made. For example:</para>

    <programlisting>Map metadata = new HashMap();
Object response = remotingClient.invoke(myPayloadObject, metadata);
String responseCodeMessage = (String) metadata.get(HTTPMetadataConstants.RESPONSE_CODE_MESSAGE);</programlisting>

    <para>Will be used as key to put the response code message in the return
    payload map from invocation handler. For example:</para>

    <programlisting>public Object invoke(InvocationRequest invocation) throws Throwable
{
   Map responseHeaders = invocation.getReturnPayload();
   responseHeaders.put(
           HTTPMetadataConstants.RESPONSE_CODE_MESSAGE,
           "Custom response code and message from remoting server");</programlisting>

    <para><emphasis role="bold">RESPONSE_HEADERS</emphasis> (actual value is
    'ResponseHeaders') - key for returning the value of
    <methodname>java.net.URLConnection.getHeaderFields()</methodname>. In other
    words, a map containing all of the response headers is stored in the
    metadata map. For example,</para>
    
    <programlisting>Object payload = ... ;
HashMap metadata = new HashMap();
client.invoke(payload, metadata);
Map responseHeaders = (Map) metadata.get(HTTPMetadataConstants.RESPONSE_HEADERS);</programlisting>
   
    <para><emphasis role="bold">NO_THROW_ON_ERROR</emphasis> (actual value is
    'NoThrowOnError') - key indicating if http client invoker (for transports
    http, https, servlet, and sslservlet) should throw an exception if the
    server response code is equal to or greater than 400. Unless set to true,
    the client invoker will by default throw either the exception that
    originated on the server (if using remoting server) or throw a
    org.jboss.remoting.transport.http.WebServerError, whose message will be
    the error html returned from the web server.</para>

    <para><emphasis role="bold">DONT_RETURN_EXCEPTION</emphasis> (actual value
    is 'dont-return-exception') - key indicating if
    <classname>org.jboss.remoting.transport.servlet.ServletServerInvoker</classname>
    should revert to the orginal error handling behavior of returning an error
    message.</para>

    <para><emphasis role="bold">USE_REMOTING_CONTENT_TYPE</emphasis> (actual value
    is 'useRemotingContentType') - key indicating if 
    <classname>org.jboss.remoting.marshal.http.HTTPUnMarshaller</classname>
    should determine that it is reading a String by using the "content-type"
    return header (if set to "false") or the "remotingContentType" header
    if set to "true".  The default value is "false", to avoid introducing any
    inconsistent behavior between versions, but, if the
    <classname>org.jboss.remoting.ServerInvocationHandler</classname> sets
    the content-type return header, then this parameter should be set to "true".</para>
    
    <para>For every http client request made from remoting client, a remoting
    version and remoting specific user agent will be set as a request
    property. The request property key for the remoting version will be
    'JBoss-Remoting-Version' and the value will be set based on return from
    call to Version.getDefaultVersion(). The 'User-Agent' request property
    value will be set to the evaluation of '"JBossRemoting - " +
    Version.VERSION'.</para>

    </section>
    
    <section>
    <title>org.jboss.remoting.transport.http.ssl.HTTPSClientInvoker</title>

    <para><emphasis role="bold">IGNORE_HTTPS_HOST</emphasis> (actual value is
    'org.jboss.security.ignoreHttpsHost') - key indicating if the http client
    invoker (for transports https and sslservlet) should ignore host name
    verification (meaning will not check for URL's hostname and server's
    identification hostname mismatch during handshaking). By default, if this
    not set to true, standard hostname verification will be performed.</para>

    <para><emphasis role="bold">HOSTNAME_VERIFIER</emphasis> (actual value is
    'hostnameVerifier') - key indicating the hostname verifier that should be
    used by the http client invoker. The value should be the fully qualified
    classname of class that implements javax.net.ssl.HostnameVerifier and has
    a void constructor.</para>

    </section>

    <section>
    <title>org.jboss.remoting.transport.rmi.RMIServerInvoker</title>

    <para><emphasis role="bold">REGISTRY_PORT_KEY</emphasis> (actual value is
    'registryPort') - the port on which to create the RMI registry. The
    default is 3455. This also needs to have the isParam attribute set to
    true.</para>

    <para><emphasis role="bold">RMI_ONEWAY_MARSHALLING</emphasis> (actual value
    is 'rmiOnewayMarshalling') - if set to "true" will cause the RMI transport
    to use the original client to server marshalling behavior.</para>

    </section>

    <section>
    <title>org.jboss.remoting.transport.servlet.ServletServerInvoker</title>

    <para><emphasis role="bold">UNWRAP_SINGLETON_ARRAYS</emphasis> (actual value
    is 'unwrapSingletonArrays') - If the map returned by
    <methodname>javax.servlet.http.HttpServletRequest.getParameterMap()</methodname>
    maps a String key to an array of length one, the value in the array will be
    extracted and associated with the key.</para>
    </section> 
    
    <section>
    <title>org.jboss.remoting.transport.socket.MicroSocketClientInvoker</title>

    <para><emphasis role="bold">TCP_NODELAY_FLAG</emphasis> (actual value is
    'enableTcpNoDelay') - can be either true or false and will indicate if
    client socket should have TCP_NODELAY turned on or off. TCP_NODELAY is for
    a specific purpose; to disable the Nagle buffering algorithm. It should
    only be set for applications that send frequent small bursts of
    information without getting an immediate response; where timely delivery
    of data is required (the canonical example is mouse movements). The
    default is false.</para>

    <para><emphasis role="bold">MAX_POOL_SIZE_FLAG</emphasis> (actual value is
    'clientMaxPoolSize') - the client side maximum number of threads. The
    default is 50.</para>

    <para><emphasis role="bold">CLIENT_SOCKET_CLASS_FLAG</emphasis> (actual
    value is 'clientSocketClass') - specifies the fully qualified class name
    for the custom SocketWrapper implementation to use on the client. Note,
    will need to make sure this is marked as a client parameter (using the
    'isParam' attribute). Making this change will not affect the
    marshaller/unmarshaller that is used, which may also be a
    requirement.</para>
    
    <para><emphasis role="bold">USE_ONEWAY_CONNECTION_TIMEOUT</emphasis> (actual value "useOnewayConnectionTimeout") -
    indicates if, during a client side oneway invocation,
    <classname>MicroSocketClientInvoker</classname> should wait for a version
    byte from the server, which prevents the anomalous behavior described in
    JBREM-706 "In socket transport, prevent client side oneway invocations from
    artificially reducing concurrency". The default value is "true".</para>
    
    </section>
    
    <section>
    <title>org.jboss.remoting.transport.socket.ServerThread</title>
            
      <para><emphasis role="bold">EVICTABILITY_TIMEOUT</emphasis> (actual value
      "evictabilityTimeout") - indicates the number of milliseconds during which
      a server thread waiting for the next invocation will not be
      preemptible.</para>
     
      <para><emphasis role="bold">CONTINUE_AFTER_TIMEOUT</emphasis> (actual
      value "continueAfterTimeout") - indicates what a server thread should do
      after experiencing a
      <classname>java.net.SocketTimeoutException</classname>. If set to "true",
      or if JBossSerialization is being used, the server thread will continue to
      wait for an invocation; otherwise, it will return itself to the thread
      pool.</para>
     
   </section>                                                                        
    
    <section>
    <title>org.jboss.remoting.transport.socket.SocketServerInvoker</title>

    <para><emphasis role="bold">CHECK_CONNECTION_KEY</emphasis> (actual value
    is 'socket.check_connection') - key for indicating if socket invoker
    should continue to keep socket connection between client and server open
    after invocations by sending a ping on the connection before being
    re-used. The default for this is false.</para>

    <para><emphasis role="bold">SERVER_SOCKET_CLASS_FLAG</emphasis> (actual
    value is 'serverSocketClass') - specifies the fully qualified class name
    for the custom SocketWrapper implementation to use on the server.</para>
        
    <para><emphasis role="bold">Bean properties (meaning have getter/setter):</emphasis></para>

    <para><emphasis role="bold">ImmediateShutdown</emphasis> - a flag for indicating
    that <classname>SocketServerInvoker</classname> should shut down all of its
    <classname>ServerThreads</classname> immediately instead of waiting for any
    current invocations to finish.</para>
    
    </section>
    
    <section>
    <title>org.jboss.remoting.transport.socket.SocketWrapper</title>

    <para><emphasis role="bold">WRITE_TIMEOUT</emphasis> (actual value
    is 'writeTimeout') - key for configuring the "write timeout" facility.  If set to
    a value greater than 0, then a write operation that does not complete within
    the configured number of milliseconds will be terminated and the socket will
    be closed. The default value is -1.</para>
    </section>
    
  </section>
</chapter>
